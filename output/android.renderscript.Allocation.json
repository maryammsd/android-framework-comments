{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/renderscript/Allocation.java",
  "packageName" : "android.renderscript",
  "className" : "Allocation",
  "comment" : "\n * <p> This class provides the primary method through which data is passed to\n * and from RenderScript kernels.  An Allocation provides the backing store for\n * a given {@link android.renderscript.Type}.  </p>\n *\n * <p>An Allocation also contains a set of usage flags that denote how the\n * Allocation could be used. For example, an Allocation may have usage flags\n * specifying that it can be used from a script as well as input to a {@link\n * android.renderscript.Sampler}. A developer must synchronize across these\n * different usages using {@link android.renderscript.Allocation#syncAll} in\n * order to ensure that different users of the Allocation have a consistent view\n * of memory. For example, in the case where an Allocation is used as the output\n * of one kernel and as Sampler input in a later kernel, a developer must call\n * {@link #syncAll syncAll(Allocation.USAGE_SCRIPT)} prior to launching the\n * second kernel to ensure correctness.\n *\n * <p>An Allocation can be populated with the {@link #copyFrom} routines. For\n * more complex Element types, the {@link #copyFromUnchecked} methods can be\n * used to copy from byte arrays or similar constructs.</p>\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For more information about creating an application that uses RenderScript, read the\n * <a href=\"{@docRoot}guide/topics/renderscript/index.html\">RenderScript</a> developer guide.</p>\n * </div>\n *\n * @deprecated Renderscript has been deprecated in API level 31. Please refer to the <a\n * href=\"https://developer.android.com/guide/topics/renderscript/migration-guide\">migration\n * guide</a> for the proposed alternatives.\n *",
  "links" : [ "android.renderscript.Type", "#copyFromUnchecked", "android.renderscript.Sampler", "android.renderscript.Allocation#syncAll", "#copyFrom", "#syncAll" ],
  "variables" : [ {
    "name" : "MAX_NUMBER_IO_INPUT_ALLOC",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mType",
    "type" : "Type",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOwningType",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBitmap",
    "type" : "Bitmap",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUsage",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAdaptedAllocation",
    "type" : "Allocation",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSize",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMipmapControl",
    "type" : "MipmapControl",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTimeStamp",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mReadAllowed",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWriteAllowed",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAutoPadding",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSelectedX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSelectedY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSelectedZ",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSelectedLOD",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSelectedArray",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSelectedFace",
    "type" : "Type.CubemapFace",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCurrentDimX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCurrentDimY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCurrentDimZ",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCurrentCount",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAllocationMap",
    "type" : "HashMap<Long, Allocation>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBufferNotifier",
    "type" : "OnBufferAvailableListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGetSurfaceSurface",
    "type" : "Surface",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mByteBuffer",
    "type" : "ByteBuffer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mByteBufferStride",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "USAGE_SCRIPT",
    "type" : "int",
    "comment" : "\n     * The Allocation will be bound to and accessed by scripts.\n     ",
    "links" : [ ]
  }, {
    "name" : "USAGE_GRAPHICS_TEXTURE",
    "type" : "int",
    "comment" : "\n     * The Allocation will be used as a texture source by one or more graphics\n     * programs.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "USAGE_GRAPHICS_VERTEX",
    "type" : "int",
    "comment" : "\n     * The Allocation will be used as a graphics mesh.\n     *\n     * This was deprecated in API level 16.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "USAGE_GRAPHICS_CONSTANTS",
    "type" : "int",
    "comment" : "\n     * The Allocation will be used as the source of shader constants by one or\n     * more programs.\n     *\n     * This was deprecated in API level 16.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "USAGE_GRAPHICS_RENDER_TARGET",
    "type" : "int",
    "comment" : "\n     * The Allocation will be used as a target for offscreen rendering\n     *\n     * This was deprecated in API level 16.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "USAGE_IO_INPUT",
    "type" : "int",
    "comment" : "\n     * The Allocation will be used as a {@link android.view.Surface}\n     * consumer.  This usage will cause the Allocation to be created\n     * as read-only.\n     *\n     ",
    "links" : [ "android.view.Surface" ]
  }, {
    "name" : "USAGE_IO_OUTPUT",
    "type" : "int",
    "comment" : "\n     * The Allocation will be used as a {@link android.view.Surface}\n     * producer.  The dimensions and format of the {@link\n     * android.view.Surface} will be forced to those of the\n     * Allocation.\n     *\n     ",
    "links" : [ "android.view.Surface" ]
  }, {
    "name" : "USAGE_SHARED",
    "type" : "int",
    "comment" : "\n     * The Allocation's backing store will be inherited from another object\n     * (usually a {@link android.graphics.Bitmap}); copying to or from the\n     * original source Bitmap will cause a synchronization rather than a full\n     * copy.  {@link #syncAll} may also be used to synchronize the Allocation\n     * and the source Bitmap.\n     *\n     * <p>This is set by default for allocations created with {@link\n     * #createFromBitmap} in API version 18 and higher.</p>\n     *\n     ",
    "links" : [ "#createFromBitmap", "android.graphics.Bitmap", "#syncAll" ]
  }, {
    "name" : "mBitmapOptions",
    "type" : "BitmapFactory.Options",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private Element.DataType validateObjectIsPrimitiveArray(Object d, boolean checkType)",
    "returnType" : "Element.DataType",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private long getIDSafe()",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Element getElement()",
    "returnType" : "Element",
    "comment" : "\n     * Get the {@link android.renderscript.Element} of the {@link\n     * android.renderscript.Type} of the Allocation.\n     *\n     * @return Element\n     *\n     ",
    "links" : [ "android.renderscript.Element", "android.renderscript.Type" ]
  }, {
    "name" : "public int getUsage()",
    "returnType" : "int",
    "comment" : "\n     * Get the usage flags of the Allocation.\n     *\n     * @return usage this Allocation's set of the USAGE_* flags OR'd together\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public MipmapControl getMipmap()",
    "returnType" : "MipmapControl",
    "comment" : "\n     * @hide\n     * Get the Mipmap control flag of the Allocation.\n     *\n     * @return the Mipmap control flag of the Allocation\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAutoPadding(boolean useAutoPadding)",
    "returnType" : "void",
    "comment" : "\n     * Specifies the mapping between the Allocation's cells and an array's elements\n     * when data is copied from the Allocation to the array, or vice-versa.\n     *\n     * Only applies to an Allocation whose Element is a vector of length 3 (such as\n     * {@link Element#U8_3} or {@link Element#RGB_888}). Enabling this feature may make\n     * copying data from the Allocation to an array or vice-versa less efficient.\n     *\n     * <p> Vec3 Element cells are stored in an Allocation as Vec4 Element cells with\n     * the same {@link android.renderscript.Element.DataType}, with the fourth vector\n     * component treated as padding. When this feature is enabled, only the data components,\n     * i.e. the first 3 vector components of each cell, will be mapped between the array\n     * and the Allocation. When disabled, explicit mapping of the padding components\n     * is required, as described in the following example.\n     *\n     * <p> For example, when copying an integer array to an Allocation of two {@link\n     * Element#I32_3} cells using {@link #copyFrom(int[])}:\n     * <p> When disabled:\n     *     The array must have at least 8 integers, with the first 4 integers copied\n     *     to the first cell of the Allocation, and the next 4 integers copied to\n     *     the second cell. The 4th and 8th integers are mapped as the padding components.\n     *\n     * <p> When enabled:\n     *     The array just needs to have at least 6 integers, with the first 3 integers\n     *     copied to the the first cell as data components, and the next 3 copied to\n     *     the second cell. There is no mapping for the padding components.\n     *\n     * <p> Similarly, when copying a byte array to an Allocation of two {@link\n     * Element#I32_3} cells, using {@link #copyFromUnchecked(int[])}:\n     * <p> When disabled:\n     *     The array must have at least 32 bytes, with the first 16 bytes copied\n     *     to the first cell of the Allocation, and the next 16 bytes copied to\n     *     the second cell. The 13th-16th and 29th-32nd bytes are mapped as padding\n     *     components.\n     *\n     * <p> When enabled:\n     *     The array just needs to have at least 24 bytes, with the first 12 bytes copied\n     *     to the first cell of the Allocation, and the next 12 bytes copied to\n     *     the second cell. There is no mapping for the padding components.\n     *\n     * <p> Similar to copying data to an Allocation from an array, when copying data from an\n     * Allocation to an array, the padding components for Vec3 Element cells will not be\n     * copied/mapped to the array if AutoPadding is enabled.\n     *\n     * <p> Default: Disabled.\n     *\n     * @param useAutoPadding True: enable AutoPadding; False: disable AutoPadding\n     *\n     ",
    "links" : [ "android.renderscript.Element#I32_3", "android.renderscript.Element.DataType", "android.renderscript.Element#U8_3", "android.renderscript.Element#RGB_888", "#copyFromUnchecked(int", "#copyFrom(int" ]
  }, {
    "name" : "public int getBytesSize()",
    "returnType" : "int",
    "comment" : "\n     * Get the size of the Allocation in bytes.\n     *\n     * @return size of the Allocation in bytes.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "private void updateCacheInfo(Type t)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setBitmap(Bitmap b)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void finalize() throws Throwable",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void validateIsInt64()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void validateIsInt32()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void validateIsInt16OrFloat16()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void validateIsInt8()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void validateIsFloat32()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void validateIsFloat64()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void validateIsObject()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void updateFromNative()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Type getType()",
    "returnType" : "Type",
    "comment" : "\n     * Get the {@link android.renderscript.Type} of the Allocation.\n     *\n     * @return Type\n     *\n     ",
    "links" : [ "android.renderscript.Type" ]
  }, {
    "name" : "public void syncAll(int srcLocation)",
    "returnType" : "void",
    "comment" : "\n     * Propagate changes from one usage of the Allocation to the\n     * other usages of the Allocation.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public void ioSend()",
    "returnType" : "void",
    "comment" : "\n     * Send a buffer to the output stream.  The contents of the Allocation will\n     * be undefined after this operation. This operation is only valid if {@link\n     * #USAGE_IO_OUTPUT} is set on the Allocation.\n     *\n     *\n     ",
    "links" : [ "#USAGE_IO_OUTPUT" ]
  }, {
    "name" : "public void ioReceive()",
    "returnType" : "void",
    "comment" : "\n     * Receive the latest input into the Allocation. This operation\n     * is only valid if {@link #USAGE_IO_INPUT} is set on the Allocation.\n     *\n     ",
    "links" : [ "#USAGE_IO_INPUT" ]
  }, {
    "name" : "public void copyFrom(BaseObj[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy an array of RS objects to the Allocation.\n     *\n     * @param d Source array.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void validateBitmapFormat(Bitmap b)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void validateBitmapSize(Bitmap b)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void copyFromUnchecked(Object array, Element.DataType dt, int arrayLen)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void copyFromUnchecked(Object array)",
    "returnType" : "void",
    "comment" : "\n     * Copy into this Allocation from an array. This method does not guarantee\n     * that the Allocation is compatible with the input buffer; it copies memory\n     * without reinterpretation.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the Allocation {@link\n     * #getBytesSize getBytesSize()}.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must not be part of the array.\n     *\n     * @param array The source array\n     ",
    "links" : [ "#setAutoPadding", "#getBytesSize" ]
  }, {
    "name" : "public void copyFromUnchecked(int[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy into this Allocation from an array. This method does not guarantee\n     * that the Allocation is compatible with the input buffer; it copies memory\n     * without reinterpretation.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the Allocation {@link\n     * #getBytesSize getBytesSize()}.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must not be part of the array.\n     *\n     * @param d the source array\n     ",
    "links" : [ "#setAutoPadding", "#getBytesSize" ]
  }, {
    "name" : "public void copyFromUnchecked(short[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy into this Allocation from an array. This method does not guarantee\n     * that the Allocation is compatible with the input buffer; it copies memory\n     * without reinterpretation.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the Allocation {@link\n     * #getBytesSize getBytesSize()}.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must not be part of the array.\n     *\n     * @param d the source array\n     ",
    "links" : [ "#setAutoPadding", "#getBytesSize" ]
  }, {
    "name" : "public void copyFromUnchecked(byte[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy into this Allocation from an array. This method does not guarantee\n     * that the Allocation is compatible with the input buffer; it copies memory\n     * without reinterpretation.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the Allocation {@link\n     * #getBytesSize getBytesSize()}.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must not be part of the array.\n     *\n     * @param d the source array\n     ",
    "links" : [ "#setAutoPadding", "#getBytesSize" ]
  }, {
    "name" : "public void copyFromUnchecked(float[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy into this Allocation from an array. This method does not guarantee\n     * that the Allocation is compatible with the input buffer; it copies memory\n     * without reinterpretation.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the Allocation {@link\n     * #getBytesSize getBytesSize()}.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must not be part of the array.\n     *\n     * @param d the source array\n     ",
    "links" : [ "#setAutoPadding", "#getBytesSize" ]
  }, {
    "name" : "public void copyFrom(Object array)",
    "returnType" : "void",
    "comment" : "\n     * Copy into this Allocation from an array.  This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} does not match the array's\n     * primitive type.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the Allocation {@link\n     * #getBytesSize getBytesSize()}.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must not be part of the array.\n     *\n     * @param array The source array\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "#getBytesSize" ]
  }, {
    "name" : "public void copyFrom(int[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy into this Allocation from an array.  This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is not a 32 bit integer nor a vector of 32 bit\n     * integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the Allocation {@link\n     * #getBytesSize getBytesSize()}.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must not be part of the array.\n     *\n     * @param d the source array\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "#getBytesSize" ]
  }, {
    "name" : "public void copyFrom(short[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy into this Allocation from an array.  This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is not a 16 bit integer nor a vector of 16 bit\n     * integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the Allocation {@link\n     * #getBytesSize getBytesSize()}.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must not be part of the array.\n     *\n     * @param d the source array\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "#getBytesSize" ]
  }, {
    "name" : "public void copyFrom(byte[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy into this Allocation from an array.  This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is not an 8 bit integer nor a vector of 8 bit\n     * integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the Allocation {@link\n     * #getBytesSize getBytesSize()}.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must not be part of the array.\n     *\n     * @param d the source array\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "#getBytesSize" ]
  }, {
    "name" : "public void copyFrom(float[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy into this Allocation from an array.  This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is neither a 32 bit float nor a vector of\n     * 32 bit floats {@link android.renderscript.Element.DataType}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the Allocation {@link\n     * #getBytesSize getBytesSize()}.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must not be part of the array.\n     *\n     * @param d the source array\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "#getBytesSize" ]
  }, {
    "name" : "public void copyFrom(Bitmap b)",
    "returnType" : "void",
    "comment" : "\n     * Copy into an Allocation from a {@link android.graphics.Bitmap}.  The\n     * height, width, and format of the bitmap must match the existing\n     * allocation.\n     *\n     * <p>If the {@link android.graphics.Bitmap} is the same as the {@link\n     * android.graphics.Bitmap} used to create the Allocation with {@link\n     * #createFromBitmap} and {@link #USAGE_SHARED} is set on the Allocation,\n     * this will synchronize the Allocation with the latest data from the {@link\n     * android.graphics.Bitmap}, potentially avoiding the actual copy.</p>\n     *\n     * @param b the source bitmap\n     ",
    "links" : [ "#USAGE_SHARED", "#createFromBitmap", "android.graphics.Bitmap" ]
  }, {
    "name" : "public void copyFrom(Allocation a)",
    "returnType" : "void",
    "comment" : "\n     * Copy an Allocation from an Allocation.  The types of both allocations\n     * must be identical.\n     *\n     * @param a the source allocation\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFromFieldPacker(int xoff, FieldPacker fp)",
    "returnType" : "void",
    "comment" : "\n     * This is only intended to be used by auto-generated code reflected from\n     * the RenderScript script files and should not be used by developers.\n     *\n     * @param xoff\n     * @param fp\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFromFieldPacker(int xoff, int component_number, FieldPacker fp)",
    "returnType" : "void",
    "comment" : "\n     * This is only intended to be used by auto-generated code reflected from\n     * the RenderScript script files and should not be used by developers.\n     *\n     * @param xoff\n     * @param component_number\n     * @param fp\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFromFieldPacker(int xoff, int yoff, int zoff, int component_number, FieldPacker fp)",
    "returnType" : "void",
    "comment" : "\n     * This is only intended to be used by auto-generated code reflected from\n     * the RenderScript script files and should not be used by developers.\n     *\n     * @param xoff\n     * @param yoff\n     * @param zoff\n     * @param component_number\n     * @param fp\n     ",
    "links" : [ ]
  }, {
    "name" : "private void data1DChecks(int off, int count, int len, int dataSize, boolean usePadding)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void generateMipmaps()",
    "returnType" : "void",
    "comment" : "\n     * Generate a mipmap chain. This is only valid if the Type of the Allocation\n     * includes mipmaps.\n     *\n     * <p>This function will generate a complete set of mipmaps from the top\n     * level LOD and place them into the script memory space.</p>\n     *\n     * <p>If the Allocation is also using other memory spaces, a call to {@link\n     * #syncAll syncAll(Allocation.USAGE_SCRIPT)} is required.</p>\n     ",
    "links" : [ "#syncAll" ]
  }, {
    "name" : "private void copy1DRangeFromUnchecked(int off, int count, Object array, Element.DataType dt, int arrayLen)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void copy1DRangeFromUnchecked(int off, int count, Object array)",
    "returnType" : "void",
    "comment" : "\n     * Copy an array into a 1D region of this Allocation.  This method does not\n     * guarantee that the Allocation is compatible with the input buffer.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param array The source array\n     ",
    "links" : [ "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeFromUnchecked(int off, int count, int[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy an array into a 1D region of this Allocation.  This method does not\n     * guarantee that the Allocation is compatible with the input buffer.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array\n     ",
    "links" : [ "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeFromUnchecked(int off, int count, short[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy an array into a 1D region of this Allocation.  This method does not\n     * guarantee that the Allocation is compatible with the input buffer.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array\n     ",
    "links" : [ "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeFromUnchecked(int off, int count, byte[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy an array into a 1D region of this Allocation.  This method does not\n     * guarantee that the Allocation is compatible with the input buffer.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array\n     ",
    "links" : [ "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeFromUnchecked(int off, int count, float[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy an array into a 1D region of this Allocation.  This method does not\n     * guarantee that the Allocation is compatible with the input buffer.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array\n     ",
    "links" : [ "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeFrom(int off, int count, Object array)",
    "returnType" : "void",
    "comment" : "\n     * Copy an array into a 1D region of this Allocation.  This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} does not match the component type\n     * of the array passed in.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param array The source array.\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeFrom(int off, int count, int[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy an array into a 1D region of this Allocation.  This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is not an 32 bit integer nor a vector of 32 bit\n     * integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeFrom(int off, int count, short[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy an array into a 1D region of this Allocation.  This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is not an 16 bit integer nor a vector of 16 bit\n     * integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeFrom(int off, int count, byte[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy an array into a 1D region of this Allocation.  This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is not an 8 bit integer nor a vector of 8 bit\n     * integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeFrom(int off, int count, float[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy an array into a 1D region of this Allocation.  This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is neither a 32 bit float nor a vector of\n     * 32 bit floats {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array.\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeFrom(int off, int count, Allocation data, int dataOff)",
    "returnType" : "void",
    "comment" : "\n     * Copy part of an Allocation into this Allocation.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param data the source data allocation.\n     * @param dataOff off The offset of the first element in data to\n     *          be copied.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void validate2DRange(int xoff, int yoff, int w, int h)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void copy2DRangeFromUnchecked(int xoff, int yoff, int w, int h, Object array, Element.DataType dt, int arrayLen)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void copy2DRangeFrom(int xoff, int yoff, int w, int h, Object array)",
    "returnType" : "void",
    "comment" : "\n     * Copy from an array into a rectangular region in this Allocation.  The\n     * array is assumed to be tightly packed. This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} does not match the input data type.\n     *\n     * <p> The size of the region is: w * h * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param xoff X offset of the region to update in this Allocation\n     * @param yoff Y offset of the region to update in this Allocation\n     * @param w Width of the region to update\n     * @param h Height of the region to update\n     * @param array Data to be placed into the Allocation\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy2DRangeFrom(int xoff, int yoff, int w, int h, byte[] data)",
    "returnType" : "void",
    "comment" : "\n     * Copy from an array into a rectangular region in this Allocation.  The\n     * array is assumed to be tightly packed. This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is not an 8 bit integer nor a vector of 8 bit\n     * integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: w * h * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param xoff X offset of the region to update in this Allocation\n     * @param yoff Y offset of the region to update in this Allocation\n     * @param w Width of the region to update\n     * @param h Height of the region to update\n     * @param data to be placed into the Allocation\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy2DRangeFrom(int xoff, int yoff, int w, int h, short[] data)",
    "returnType" : "void",
    "comment" : "\n     * Copy from an array into a rectangular region in this Allocation.  The\n     * array is assumed to be tightly packed. This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is not a 16 bit integer nor a vector of 16 bit\n     * integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: w * h * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param xoff X offset of the region to update in this Allocation\n     * @param yoff Y offset of the region to update in this Allocation\n     * @param w Width of the region to update\n     * @param h Height of the region to update\n     * @param data to be placed into the Allocation\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy2DRangeFrom(int xoff, int yoff, int w, int h, int[] data)",
    "returnType" : "void",
    "comment" : "\n     * Copy from an array into a rectangular region in this Allocation.  The\n     * array is assumed to be tightly packed. This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is not a 32 bit integer nor a vector of 32 bit\n     * integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: w * h * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param xoff X offset of the region to update in this Allocation\n     * @param yoff Y offset of the region to update in this Allocation\n     * @param w Width of the region to update\n     * @param h Height of the region to update\n     * @param data to be placed into the Allocation\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy2DRangeFrom(int xoff, int yoff, int w, int h, float[] data)",
    "returnType" : "void",
    "comment" : "\n     * Copy from an array into a rectangular region in this Allocation.  The\n     * array is assumed to be tightly packed. This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is neither a 32 bit float nor a vector of\n     * 32 bit floats {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: w * h * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param xoff X offset of the region to update in this Allocation\n     * @param yoff Y offset of the region to update in this Allocation\n     * @param w Width of the region to update\n     * @param h Height of the region to update\n     * @param data to be placed into the Allocation\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy2DRangeFrom(int xoff, int yoff, int w, int h, Allocation data, int dataXoff, int dataYoff)",
    "returnType" : "void",
    "comment" : "\n     * Copy a rectangular region from an Allocation into a rectangular region in\n     * this Allocation.\n     *\n     * @param xoff X offset of the region in this Allocation\n     * @param yoff Y offset of the region in this Allocation\n     * @param w Width of the region to update.\n     * @param h Height of the region to update.\n     * @param data source Allocation.\n     * @param dataXoff X offset in source Allocation\n     * @param dataYoff Y offset in source Allocation\n     ",
    "links" : [ ]
  }, {
    "name" : "public void copy2DRangeFrom(int xoff, int yoff, Bitmap data)",
    "returnType" : "void",
    "comment" : "\n     * Copy a {@link android.graphics.Bitmap} into an Allocation.  The height\n     * and width of the update will use the height and width of the {@link\n     * android.graphics.Bitmap}.\n     *\n     * @param xoff X offset of the region to update in this Allocation\n     * @param yoff Y offset of the region to update in this Allocation\n     * @param data the Bitmap to be copied\n     ",
    "links" : [ "android.graphics.Bitmap" ]
  }, {
    "name" : "private void validate3DRange(int xoff, int yoff, int zoff, int w, int h, int d)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void copy3DRangeFromUnchecked(int xoff, int yoff, int zoff, int w, int h, int d, Object array, Element.DataType dt, int arrayLen)",
    "returnType" : "void",
    "comment" : "\n     * Copy a rectangular region from the array into the allocation.\n     * The array is assumed to be tightly packed.\n     *\n     * The data type of the array is not required to be the same as\n     * the element data type.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void copy3DRangeFrom(int xoff, int yoff, int zoff, int w, int h, int d, Object array)",
    "returnType" : "void",
    "comment" : "\n     * Copy from an array into a 3D region in this Allocation.  The\n     * array is assumed to be tightly packed. This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} does not match the input data type.\n     *\n     * <p> The size of the region is: w * h * d * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param xoff X offset of the region to update in this Allocation\n     * @param yoff Y offset of the region to update in this Allocation\n     * @param zoff Z offset of the region to update in this Allocation\n     * @param w Width of the region to update\n     * @param h Height of the region to update\n     * @param d Depth of the region to update\n     * @param array to be placed into the allocation\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy3DRangeFrom(int xoff, int yoff, int zoff, int w, int h, int d, Allocation data, int dataXoff, int dataYoff, int dataZoff)",
    "returnType" : "void",
    "comment" : "\n     * Copy a rectangular region into the allocation from another\n     * allocation.\n     *\n     * @param xoff X offset of the region to update in this Allocation\n     * @param yoff Y offset of the region to update in this Allocation\n     * @param zoff Z offset of the region to update in this Allocation\n     * @param w Width of the region to update.\n     * @param h Height of the region to update.\n     * @param d Depth of the region to update.\n     * @param data source allocation.\n     * @param dataXoff X offset of the region in the source Allocation\n     * @param dataYoff Y offset of the region in the source Allocation\n     * @param dataZoff Z offset of the region in the source Allocation\n     ",
    "links" : [ ]
  }, {
    "name" : "public void copyTo(Bitmap b)",
    "returnType" : "void",
    "comment" : "\n     * Copy from the Allocation into a {@link android.graphics.Bitmap}.  The\n     * bitmap must match the dimensions of the Allocation.\n     *\n     * @param b The bitmap to be set from the Allocation.\n     ",
    "links" : [ "android.graphics.Bitmap" ]
  }, {
    "name" : "private void copyTo(Object array, Element.DataType dt, int arrayLen)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void copyTo(Object array)",
    "returnType" : "void",
    "comment" : "\n     * Copy from the Allocation into an array. The method is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} does not match the input data type.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the Allocation {@link\n     * #getBytesSize getBytesSize()}.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells will be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must not be part of the array.\n     *\n     * @param array The array to be set from the Allocation.\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "#getBytesSize" ]
  }, {
    "name" : "public void copyTo(byte[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy from the Allocation into a byte array. This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is neither an 8 bit integer nor a vector of 8 bit\n     * integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the Allocation {@link\n     * #getBytesSize getBytesSize()}.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells will be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must not be part of the array.\n     *\n     * @param d The array to be set from the Allocation.\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "#getBytesSize" ]
  }, {
    "name" : "public void copyTo(short[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy from the Allocation into a short array. This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is not a 16 bit integer nor a vector of 16 bit\n     * integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the Allocation {@link\n     * #getBytesSize getBytesSize()}.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells will be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must not be part of the array.\n     *\n     * @param d The array to be set from the Allocation.\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "#getBytesSize" ]
  }, {
    "name" : "public void copyTo(int[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy from the Allocation into a int array. This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is not a 32 bit integer nor a vector of 32 bit\n     * integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the Allocation {@link\n     * #getBytesSize getBytesSize()}.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells will be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must not be part of the array.\n     *\n     * @param d The array to be set from the Allocation.\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "#getBytesSize" ]
  }, {
    "name" : "public void copyTo(float[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy from the Allocation into a float array. This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is neither a 32 bit float nor a vector of\n     * 32 bit floats {@link android.renderscript.Element.DataType}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the Allocation {@link\n     * #getBytesSize getBytesSize()}.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells will be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the Allocation {@link #getBytesSize getBytesSize()}. The padding bytes for\n     * the cells must not be part of the array.\n     *\n     * @param d The array to be set from the Allocation.\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "#getBytesSize" ]
  }, {
    "name" : "public void copyToFieldPacker(int xoff, int yoff, int zoff, int component_number, FieldPacker fp)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     *\n     * This is only intended to be used by auto-generated code reflected from\n     * the RenderScript script files and should not be used by developers.\n     *\n     * @param xoff\n     * @param yoff\n     * @param zoff\n     * @param component_number\n     * @param fp\n     ",
    "links" : [ ]
  }, {
    "name" : "public synchronized void resize(int dimX)",
    "returnType" : "void",
    "comment" : "\n     * Resize a 1D allocation.  The contents of the allocation are preserved.\n     * If new elements are allocated objects are created with null contents and\n     * the new region is otherwise undefined.\n     *\n     * <p>If the new region is smaller the references of any objects outside the\n     * new region will be released.</p>\n     *\n     * <p>A new type will be created with the new dimension.</p>\n     *\n     * @param dimX The new size of the allocation.\n     *\n     * @deprecated RenderScript objects should be immutable once created.  The\n     * replacement is to create a new allocation and copy the contents. This\n     * function will throw an exception if API 21 or higher is used.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void copy1DRangeToUnchecked(int off, int count, Object array, Element.DataType dt, int arrayLen)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void copy1DRangeToUnchecked(int off, int count, Object array)",
    "returnType" : "void",
    "comment" : "\n     * Copy a 1D region of this Allocation into an array.  This method does not\n     * guarantee that the Allocation is compatible with the input buffer.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param array The dest array\n     ",
    "links" : [ "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeToUnchecked(int off, int count, int[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy a 1D region of this Allocation into an array.  This method does not\n     * guarantee that the Allocation is compatible with the input buffer.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array\n     ",
    "links" : [ "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeToUnchecked(int off, int count, short[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy a 1D region of this Allocation into an array.  This method does not\n     * guarantee that the Allocation is compatible with the input buffer.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array\n     ",
    "links" : [ "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeToUnchecked(int off, int count, byte[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy a 1D region of this Allocation into an array.  This method does not\n     * guarantee that the Allocation is compatible with the input buffer.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array\n     ",
    "links" : [ "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeToUnchecked(int off, int count, float[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy a 1D region of this Allocation into an array.  This method does not\n     * guarantee that the Allocation is compatible with the input buffer.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array\n     ",
    "links" : [ "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeTo(int off, int count, Object array)",
    "returnType" : "void",
    "comment" : "\n     * Copy a 1D region of this Allocation into an array.  This method is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} does not match the component type\n     * of the array passed in.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param array The source array.\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeTo(int off, int count, int[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy a 1D region of this Allocation into an array. This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is neither a 32 bit integer nor a vector of 32 bit\n     * integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeTo(int off, int count, short[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy a 1D region of this Allocation into an array. This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is neither a 16 bit integer nor a vector of 16 bit\n     * integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeTo(int off, int count, byte[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy a 1D region of this Allocation into an array. This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is neither an 8 bit integer nor a vector of 8 bit\n     * integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy1DRangeTo(int off, int count, float[] d)",
    "returnType" : "void",
    "comment" : "\n     * Copy a 1D region of this Allocation into an array. This variant is type checked\n     * and will generate exceptions if the Allocation's {@link\n     * android.renderscript.Element} is neither a 32 bit float nor a vector of\n     * 32 bit floats {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: count * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param off The offset of the first element to be copied.\n     * @param count The number of elements to be copied.\n     * @param d the source array.\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : " void copy2DRangeToUnchecked(int xoff, int yoff, int w, int h, Object array, Element.DataType dt, int arrayLen)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void copy2DRangeTo(int xoff, int yoff, int w, int h, Object array)",
    "returnType" : "void",
    "comment" : "\n     * Copy from a rectangular region in this Allocation into an array. This\n     * method is type checked and will generate exceptions if the Allocation's\n     * {@link android.renderscript.Element} does not match the component type\n     * of the array passed in.\n     *\n     * <p> The size of the region is: w * h * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param xoff X offset of the region to copy in this Allocation\n     * @param yoff Y offset of the region to copy in this Allocation\n     * @param w Width of the region to copy\n     * @param h Height of the region to copy\n     * @param array Dest Array to be copied into\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy2DRangeTo(int xoff, int yoff, int w, int h, byte[] data)",
    "returnType" : "void",
    "comment" : "\n     * Copy from a rectangular region in this Allocation into an array. This\n     * variant is type checked and will generate exceptions if the Allocation's\n     * {@link android.renderscript.Element} is neither an 8 bit integer nor a vector\n     * of 8 bit integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: w * h * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param xoff X offset of the region to copy in this Allocation\n     * @param yoff Y offset of the region to copy in this Allocation\n     * @param w Width of the region to copy\n     * @param h Height of the region to copy\n     * @param data Dest Array to be copied into\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy2DRangeTo(int xoff, int yoff, int w, int h, short[] data)",
    "returnType" : "void",
    "comment" : "\n     * Copy from a rectangular region in this Allocation into an array. This\n     * variant is type checked and will generate exceptions if the Allocation's\n     * {@link android.renderscript.Element} is neither a 16 bit integer nor a vector\n     * of 16 bit integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: w * h * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param xoff X offset of the region to copy in this Allocation\n     * @param yoff Y offset of the region to copy in this Allocation\n     * @param w Width of the region to copy\n     * @param h Height of the region to copy\n     * @param data Dest Array to be copied into\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy2DRangeTo(int xoff, int yoff, int w, int h, int[] data)",
    "returnType" : "void",
    "comment" : "\n     * Copy from a rectangular region in this Allocation into an array. This\n     * variant is type checked and will generate exceptions if the Allocation's\n     * {@link android.renderscript.Element} is neither a 32 bit integer nor a vector\n     * of 32 bit integers {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: w * h * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param xoff X offset of the region to copy in this Allocation\n     * @param yoff Y offset of the region to copy in this Allocation\n     * @param w Width of the region to copy\n     * @param h Height of the region to copy\n     * @param data Dest Array to be copied into\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public void copy2DRangeTo(int xoff, int yoff, int w, int h, float[] data)",
    "returnType" : "void",
    "comment" : "\n     * Copy from a rectangular region in this Allocation into an array. This\n     * variant is type checked and will generate exceptions if the Allocation's\n     * {@link android.renderscript.Element} is neither a 32 bit float nor a vector\n     * of 32 bit floats {@link android.renderscript.Element.DataType}.\n     *\n     * <p> The size of the region is: w * h * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param xoff X offset of the region to copy in this Allocation\n     * @param yoff Y offset of the region to copy in this Allocation\n     * @param w Width of the region to copy\n     * @param h Height of the region to copy\n     * @param data Dest Array to be copied into\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element.DataType", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "private void copy3DRangeToUnchecked(int xoff, int yoff, int zoff, int w, int h, int d, Object array, Element.DataType dt, int arrayLen)",
    "returnType" : "void",
    "comment" : "\n     * Copy from a 3D region in this Allocation into an array. This method does\n     * not guarantee that the Allocation is compatible with the input buffer.\n     * The array is assumed to be tightly packed.\n     *\n     * The data type of the array is not required to be the same as\n     * the element data type.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void copy3DRangeTo(int xoff, int yoff, int zoff, int w, int h, int d, Object array)",
    "returnType" : "void",
    "comment" : "\n     * Copy from a 3D region in this Allocation into an array. This\n     * method is type checked and will generate exceptions if the Allocation's\n     * {@link android.renderscript.Element} does not match the component type\n     * of the array passed in.\n     *\n     * <p> The size of the region is: w * h * d * {@link #getElement}.{@link\n     * Element#getBytesSize}.\n     *\n     * <p> If the Allocation does not have Vec3 Elements, then the size of the\n     * array in bytes must be at least the size of the region.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is disabled, then the size of the array in bytes must be at least the size\n     * of the region. The padding bytes for the cells must be part of the array.\n     *\n     * <p> If the Allocation has Vec3 Elements and {@link #setAutoPadding AutoPadding}\n     * is enabled, then the size of the array in bytes must be at least 3/4 the size\n     * of the region. The padding bytes for the cells must not be part of the array.\n     *\n     * @param xoff X offset of the region to copy in this Allocation\n     * @param yoff Y offset of the region to copy in this Allocation\n     * @param zoff Z offset of the region to copy in this Allocation\n     * @param w Width of the region to copy\n     * @param h Height of the region to copy\n     * @param d Depth of the region to copy\n     * @param array Dest Array to be copied into\n     ",
    "links" : [ "android.renderscript.Element", "#setAutoPadding", "android.renderscript.Element#getBytesSize", "#getElement" ]
  }, {
    "name" : "public static Allocation createTyped(RenderScript rs, Type type, MipmapControl mips, int usage)",
    "returnType" : "Allocation",
    "comment" : "\n     * Creates a new Allocation with the given {@link\n     * android.renderscript.Type}, mipmap flag, and usage flags.\n     *\n     * @param type RenderScript type describing data layout\n     * @param mips specifies desired mipmap behaviour for the\n     *             allocation\n     * @param usage bit field specifying how the Allocation is\n     *              utilized\n     ",
    "links" : [ "android.renderscript.Type" ]
  }, {
    "name" : "public static Allocation createTyped(RenderScript rs, Type type, int usage)",
    "returnType" : "Allocation",
    "comment" : "\n     * Creates an Allocation with the size specified by the type and no mipmaps\n     * generated by default\n     *\n     * @param rs Context to which the allocation will belong.\n     * @param type renderscript type describing data layout\n     * @param usage bit field specifying how the allocation is\n     *              utilized\n     *\n     * @return allocation\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Allocation createTyped(RenderScript rs, Type type)",
    "returnType" : "Allocation",
    "comment" : "\n     * Creates an Allocation for use by scripts with a given {@link\n     * android.renderscript.Type} and no mipmaps\n     *\n     * @param rs Context to which the Allocation will belong.\n     * @param type RenderScript Type describing data layout\n     *\n     * @return allocation\n     ",
    "links" : [ "android.renderscript.Type" ]
  }, {
    "name" : "public static Allocation createSized(RenderScript rs, Element e, int count, int usage)",
    "returnType" : "Allocation",
    "comment" : "\n     * Creates an Allocation with a specified number of given elements\n     *\n     * @param rs Context to which the Allocation will belong.\n     * @param e Element to use in the Allocation\n     * @param count the number of Elements in the Allocation\n     * @param usage bit field specifying how the Allocation is\n     *              utilized\n     *\n     * @return allocation\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Allocation createSized(RenderScript rs, Element e, int count)",
    "returnType" : "Allocation",
    "comment" : "\n     * Creates an Allocation with a specified number of given elements\n     *\n     * @param rs Context to which the Allocation will belong.\n     * @param e Element to use in the Allocation\n     * @param count the number of Elements in the Allocation\n     *\n     * @return allocation\n     ",
    "links" : [ ]
  }, {
    "name" : " static Element elementFromBitmap(RenderScript rs, Bitmap b)",
    "returnType" : "Element",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static Type typeFromBitmap(RenderScript rs, Bitmap b, MipmapControl mip)",
    "returnType" : "Type",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static Allocation createFromBitmap(RenderScript rs, Bitmap b, MipmapControl mips, int usage)",
    "returnType" : "Allocation",
    "comment" : "\n     * Creates an Allocation from a {@link android.graphics.Bitmap}.\n     *\n     * @param rs Context to which the allocation will belong.\n     * @param b Bitmap source for the allocation data\n     * @param mips specifies desired mipmap behaviour for the\n     *             allocation\n     * @param usage bit field specifying how the allocation is\n     *              utilized\n     *\n     * @return Allocation containing bitmap data\n     *\n     ",
    "links" : [ "android.graphics.Bitmap" ]
  }, {
    "name" : "public ByteBuffer getByteBuffer()",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Gets or creates a ByteBuffer that contains the raw data of the current Allocation.\n     * <p> If the Allocation is created with USAGE_IO_INPUT, the returned ByteBuffer\n     * would contain the up-to-date data as READ ONLY.\n     * For a 2D or 3D Allocation, the raw data maybe padded so that each row of\n     * the Allocation has certain alignment. The size of each row including padding,\n     * called stride, can be queried using the {@link #getStride()} method.\n     *\n     * Note: Operating on the ByteBuffer of a destroyed Allocation will triger errors.\n     *\n     * @return ByteBuffer The ByteBuffer associated with raw data pointer of the Allocation.\n     ",
    "links" : [ "#getStride()" ]
  }, {
    "name" : "public static Allocation[] createAllocations(RenderScript rs, Type t, int usage, int numAlloc)",
    "returnType" : "Allocation[]",
    "comment" : "\n     * Creates a new Allocation Array with the given {@link\n     * android.renderscript.Type}, and usage flags.\n     * Note: If the input allocation is of usage: USAGE_IO_INPUT,\n     * the created Allocation will be sharing the same BufferQueue.\n     *\n     * @param rs RenderScript context\n     * @param t RenderScript type describing data layout\n     * @param usage bit field specifying how the Allocation is\n     *              utilized\n     * @param numAlloc Number of Allocations in the array.\n     * @return Allocation[]\n     ",
    "links" : [ "android.renderscript.Type" ]
  }, {
    "name" : " static Allocation createFromAllocation(RenderScript rs, Allocation alloc)",
    "returnType" : "Allocation",
    "comment" : "\n     * Creates a new Allocation with the given {@link\n     * android.renderscript.Allocation}. The same data layout of\n     * the input Allocation will be applied.\n     * <p> If the input allocation is of usage: USAGE_IO_INPUT, the created\n     * Allocation will be sharing the same BufferQueue.\n     *\n     * @param rs Context to which the allocation will belong.\n     * @param alloc RenderScript Allocation describing data layout.\n     * @return Allocation sharing the same data structure.\n     ",
    "links" : [ "android.renderscript.Allocation" ]
  }, {
    "name" : " void setupBufferQueue(int numAlloc)",
    "returnType" : "void",
    "comment" : "\n     * Initialize BufferQueue with specified max number of buffers.\n     ",
    "links" : [ ]
  }, {
    "name" : " void shareBufferQueue(Allocation alloc)",
    "returnType" : "void",
    "comment" : "\n     * Share the BufferQueue with another {@link #USAGE_IO_INPUT} Allocation.\n     *\n     * @param alloc Allocation to associate with allocation\n     ",
    "links" : [ "#USAGE_IO_INPUT" ]
  }, {
    "name" : "public long getStride()",
    "returnType" : "long",
    "comment" : "\n     * Gets the stride of the Allocation.\n     * For a 2D or 3D Allocation, the raw data maybe padded so that each row of\n     * the Allocation has certain alignment. The size of each row including such\n     * padding is called stride.\n     *\n     * @return the stride. For 1D Allocation, the stride will be the number of\n     *         bytes of this Allocation. For 2D and 3D Allocations, the stride\n     *         will be the stride in X dimension measuring in bytes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getTimeStamp()",
    "returnType" : "long",
    "comment" : "\n     * Get the timestamp for the most recent buffer held by this Allocation.\n     * The timestamp is guaranteed to be unique and monotonically increasing.\n     * Default value: -1. The timestamp will be updated after each {@link\n     * #ioReceive ioReceive()} call.\n     *\n     * It can be used to identify the images by comparing the unique timestamps\n     * when used with {@link android.hardware.camera2} APIs.\n     * Example steps:\n     *   1. Save {@link android.hardware.camera2.TotalCaptureResult} when the\n     *      capture is completed.\n     *   2. Get the timestamp after {@link #ioReceive ioReceive()} call.\n     *   3. Comparing totalCaptureResult.get(CaptureResult.SENSOR_TIMESTAMP) with\n     *      alloc.getTimeStamp().\n     * @return long Timestamp associated with the buffer held by the Allocation.\n     ",
    "links" : [ "#ioReceive", "android.hardware.camera2", "android.hardware.camera2.TotalCaptureResult" ]
  }, {
    "name" : "public Surface getSurface()",
    "returnType" : "Surface",
    "comment" : "\n     * Returns the handle to a raw buffer that is being managed by the screen\n     * compositor. This operation is only valid for Allocations with {@link\n     * #USAGE_IO_INPUT}.\n     *\n     * @return Surface object associated with allocation\n     *\n     ",
    "links" : [ "#USAGE_IO_INPUT" ]
  }, {
    "name" : "public void setSurface(Surface sur)",
    "returnType" : "void",
    "comment" : "\n     * Associate a {@link android.view.Surface} with this Allocation. This\n     * operation is only valid for Allocations with {@link #USAGE_IO_OUTPUT}.\n     *\n     * @param sur Surface to associate with allocation\n     ",
    "links" : [ "android.view.Surface", "#USAGE_IO_OUTPUT" ]
  }, {
    "name" : "public static Allocation createFromBitmap(RenderScript rs, Bitmap b)",
    "returnType" : "Allocation",
    "comment" : "\n     * Creates an Allocation from a {@link android.graphics.Bitmap}.\n     *\n     * <p>With target API version 18 or greater, this Allocation will be created\n     * with {@link #USAGE_SHARED}, {@link #USAGE_SCRIPT}, and {@link\n     * #USAGE_GRAPHICS_TEXTURE}. With target API version 17 or lower, this\n     * Allocation will be created with {@link #USAGE_GRAPHICS_TEXTURE}.</p>\n     *\n     * @param rs Context to which the allocation will belong.\n     * @param b bitmap source for the allocation data\n     *\n     * @return Allocation containing bitmap data\n     *\n     ",
    "links" : [ "#USAGE_GRAPHICS_TEXTURE", "#USAGE_SHARED", "android.graphics.Bitmap", "#USAGE_SCRIPT" ]
  }, {
    "name" : "public static Allocation createCubemapFromBitmap(RenderScript rs, Bitmap b, MipmapControl mips, int usage)",
    "returnType" : "Allocation",
    "comment" : "\n     * Creates a cubemap Allocation from a {@link android.graphics.Bitmap}\n     * containing the horizontal list of cube faces. Each face must be a square,\n     * have the same size as all other faces, and have a width that is a power\n     * of 2.\n     *\n     * @param rs Context to which the allocation will belong.\n     * @param b Bitmap with cubemap faces layed out in the following\n     *          format: right, left, top, bottom, front, back\n     * @param mips specifies desired mipmap behaviour for the cubemap\n     * @param usage bit field specifying how the cubemap is utilized\n     *\n     * @return allocation containing cubemap data\n     *\n     ",
    "links" : [ "android.graphics.Bitmap" ]
  }, {
    "name" : "public static Allocation createCubemapFromBitmap(RenderScript rs, Bitmap b)",
    "returnType" : "Allocation",
    "comment" : "\n     * Creates a non-mipmapped cubemap Allocation for use as a graphics texture\n     * from a {@link android.graphics.Bitmap} containing the horizontal list of\n     * cube faces. Each face must be a square, have the same size as all other\n     * faces, and have a width that is a power of 2.\n     *\n     * @param rs Context to which the allocation will belong.\n     * @param b bitmap with cubemap faces layed out in the following\n     *          format: right, left, top, bottom, front, back\n     *\n     * @return allocation containing cubemap data\n     *\n     ",
    "links" : [ "android.graphics.Bitmap" ]
  }, {
    "name" : "public static Allocation createCubemapFromCubeFaces(RenderScript rs, Bitmap xpos, Bitmap xneg, Bitmap ypos, Bitmap yneg, Bitmap zpos, Bitmap zneg, MipmapControl mips, int usage)",
    "returnType" : "Allocation",
    "comment" : "\n     * Creates a cubemap Allocation from 6 {@link android.graphics.Bitmap}\n     * objects containing the cube faces. Each face must be a square, have the\n     * same size as all other faces, and have a width that is a power of 2.\n     *\n     * @param rs Context to which the allocation will belong.\n     * @param xpos cubemap face in the positive x direction\n     * @param xneg cubemap face in the negative x direction\n     * @param ypos cubemap face in the positive y direction\n     * @param yneg cubemap face in the negative y direction\n     * @param zpos cubemap face in the positive z direction\n     * @param zneg cubemap face in the negative z direction\n     * @param mips specifies desired mipmap behaviour for the cubemap\n     * @param usage bit field specifying how the cubemap is utilized\n     *\n     * @return allocation containing cubemap data\n     *\n     ",
    "links" : [ "android.graphics.Bitmap" ]
  }, {
    "name" : "public static Allocation createCubemapFromCubeFaces(RenderScript rs, Bitmap xpos, Bitmap xneg, Bitmap ypos, Bitmap yneg, Bitmap zpos, Bitmap zneg)",
    "returnType" : "Allocation",
    "comment" : "\n     * Creates a non-mipmapped cubemap Allocation for use as a sampler input\n     * from 6 {@link android.graphics.Bitmap} objects containing the cube\n     * faces. Each face must be a square, have the same size as all other faces,\n     * and have a width that is a power of 2.\n     *\n     * @param rs Context to which the allocation will belong.\n     * @param xpos cubemap face in the positive x direction\n     * @param xneg cubemap face in the negative x direction\n     * @param ypos cubemap face in the positive y direction\n     * @param yneg cubemap face in the negative y direction\n     * @param zpos cubemap face in the positive z direction\n     * @param zneg cubemap face in the negative z direction\n     *\n     * @return allocation containing cubemap data\n     *\n     ",
    "links" : [ "android.graphics.Bitmap" ]
  }, {
    "name" : "public static Allocation createFromBitmapResource(RenderScript rs, Resources res, int id, MipmapControl mips, int usage)",
    "returnType" : "Allocation",
    "comment" : "\n     * Creates an Allocation from the Bitmap referenced\n     * by resource ID.\n     *\n     * @param rs Context to which the allocation will belong.\n     * @param res application resources\n     * @param id resource id to load the data from\n     * @param mips specifies desired mipmap behaviour for the\n     *             allocation\n     * @param usage bit field specifying how the allocation is\n     *              utilized\n     *\n     * @return Allocation containing resource data\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Allocation createFromBitmapResource(RenderScript rs, Resources res, int id)",
    "returnType" : "Allocation",
    "comment" : "\n     * Creates a non-mipmapped Allocation to use as a graphics texture from the\n     * {@link android.graphics.Bitmap} referenced by resource ID.\n     *\n     * <p>With target API version 18 or greater, this allocation will be created\n     * with {@link #USAGE_SCRIPT} and {@link #USAGE_GRAPHICS_TEXTURE}. With\n     * target API version 17 or lower, this allocation will be created with\n     * {@link #USAGE_GRAPHICS_TEXTURE}.</p>\n     *\n     * @param rs Context to which the allocation will belong.\n     * @param res application resources\n     * @param id resource id to load the data from\n     *\n     * @return Allocation containing resource data\n     *\n     ",
    "links" : [ "#USAGE_GRAPHICS_TEXTURE", "android.graphics.Bitmap", "#USAGE_SCRIPT" ]
  }, {
    "name" : "public static Allocation createFromString(RenderScript rs, String str, int usage)",
    "returnType" : "Allocation",
    "comment" : "\n     * Creates an Allocation containing string data encoded in UTF-8 format.\n     *\n     * @param rs Context to which the allocation will belong.\n     * @param str string to create the allocation from\n     * @param usage bit field specifying how the allocaiton is\n     *              utilized\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnBufferAvailableListener(OnBufferAvailableListener callback)",
    "returnType" : "void",
    "comment" : "\n     * Set a notification handler for {@link #USAGE_IO_INPUT}.\n     *\n     * @param callback instance of the OnBufferAvailableListener\n     *                 class to be called when buffer arrive.\n     ",
    "links" : [ "#USAGE_IO_INPUT" ]
  }, {
    "name" : " static void sendBufferNotification(long id)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void destroy()",
    "returnType" : "void",
    "comment" : "\n     * For USAGE_IO_OUTPUT, destroy() implies setSurface(null).\n     *\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "private Element.DataType validateObjectIsPrimitiveArray(Object d, boolean checkType)", "private long getIDSafe()", "public Element getElement()", "public int getUsage()", "public MipmapControl getMipmap()", "public void setAutoPadding(boolean useAutoPadding)", "public int getBytesSize()", "private void updateCacheInfo(Type t)", "private void setBitmap(Bitmap b)", "protected void finalize() throws Throwable", "private void validateIsInt64()", "private void validateIsInt32()", "private void validateIsInt16OrFloat16()", "private void validateIsInt8()", "private void validateIsFloat32()", "private void validateIsFloat64()", "private void validateIsObject()", " void updateFromNative()", "public Type getType()", "public void syncAll(int srcLocation)", "public void ioSend()", "public void ioReceive()", "public void copyFrom(BaseObj[] d)", "private void validateBitmapFormat(Bitmap b)", "private void validateBitmapSize(Bitmap b)", "private void copyFromUnchecked(Object array, Element.DataType dt, int arrayLen)", "public void copyFromUnchecked(Object array)", "public void copyFromUnchecked(int[] d)", "public void copyFromUnchecked(short[] d)", "public void copyFromUnchecked(byte[] d)", "public void copyFromUnchecked(float[] d)", "public void copyFrom(Object array)", "public void copyFrom(int[] d)", "public void copyFrom(short[] d)", "public void copyFrom(byte[] d)", "public void copyFrom(float[] d)", "public void copyFrom(Bitmap b)", "public void copyFrom(Allocation a)", "public void setFromFieldPacker(int xoff, FieldPacker fp)", "public void setFromFieldPacker(int xoff, int component_number, FieldPacker fp)", "public void setFromFieldPacker(int xoff, int yoff, int zoff, int component_number, FieldPacker fp)", "private void data1DChecks(int off, int count, int len, int dataSize, boolean usePadding)", "public void generateMipmaps()", "private void copy1DRangeFromUnchecked(int off, int count, Object array, Element.DataType dt, int arrayLen)", "public void copy1DRangeFromUnchecked(int off, int count, Object array)", "public void copy1DRangeFromUnchecked(int off, int count, int[] d)", "public void copy1DRangeFromUnchecked(int off, int count, short[] d)", "public void copy1DRangeFromUnchecked(int off, int count, byte[] d)", "public void copy1DRangeFromUnchecked(int off, int count, float[] d)", "public void copy1DRangeFrom(int off, int count, Object array)", "public void copy1DRangeFrom(int off, int count, int[] d)", "public void copy1DRangeFrom(int off, int count, short[] d)", "public void copy1DRangeFrom(int off, int count, byte[] d)", "public void copy1DRangeFrom(int off, int count, float[] d)", "public void copy1DRangeFrom(int off, int count, Allocation data, int dataOff)", "private void validate2DRange(int xoff, int yoff, int w, int h)", " void copy2DRangeFromUnchecked(int xoff, int yoff, int w, int h, Object array, Element.DataType dt, int arrayLen)", "public void copy2DRangeFrom(int xoff, int yoff, int w, int h, Object array)", "public void copy2DRangeFrom(int xoff, int yoff, int w, int h, byte[] data)", "public void copy2DRangeFrom(int xoff, int yoff, int w, int h, short[] data)", "public void copy2DRangeFrom(int xoff, int yoff, int w, int h, int[] data)", "public void copy2DRangeFrom(int xoff, int yoff, int w, int h, float[] data)", "public void copy2DRangeFrom(int xoff, int yoff, int w, int h, Allocation data, int dataXoff, int dataYoff)", "public void copy2DRangeFrom(int xoff, int yoff, Bitmap data)", "private void validate3DRange(int xoff, int yoff, int zoff, int w, int h, int d)", "private void copy3DRangeFromUnchecked(int xoff, int yoff, int zoff, int w, int h, int d, Object array, Element.DataType dt, int arrayLen)", "public void copy3DRangeFrom(int xoff, int yoff, int zoff, int w, int h, int d, Object array)", "public void copy3DRangeFrom(int xoff, int yoff, int zoff, int w, int h, int d, Allocation data, int dataXoff, int dataYoff, int dataZoff)", "public void copyTo(Bitmap b)", "private void copyTo(Object array, Element.DataType dt, int arrayLen)", "public void copyTo(Object array)", "public void copyTo(byte[] d)", "public void copyTo(short[] d)", "public void copyTo(int[] d)", "public void copyTo(float[] d)", "public void copyToFieldPacker(int xoff, int yoff, int zoff, int component_number, FieldPacker fp)", "public synchronized void resize(int dimX)", "private void copy1DRangeToUnchecked(int off, int count, Object array, Element.DataType dt, int arrayLen)", "public void copy1DRangeToUnchecked(int off, int count, Object array)", "public void copy1DRangeToUnchecked(int off, int count, int[] d)", "public void copy1DRangeToUnchecked(int off, int count, short[] d)", "public void copy1DRangeToUnchecked(int off, int count, byte[] d)", "public void copy1DRangeToUnchecked(int off, int count, float[] d)", "public void copy1DRangeTo(int off, int count, Object array)", "public void copy1DRangeTo(int off, int count, int[] d)", "public void copy1DRangeTo(int off, int count, short[] d)", "public void copy1DRangeTo(int off, int count, byte[] d)", "public void copy1DRangeTo(int off, int count, float[] d)", " void copy2DRangeToUnchecked(int xoff, int yoff, int w, int h, Object array, Element.DataType dt, int arrayLen)", "public void copy2DRangeTo(int xoff, int yoff, int w, int h, Object array)", "public void copy2DRangeTo(int xoff, int yoff, int w, int h, byte[] data)", "public void copy2DRangeTo(int xoff, int yoff, int w, int h, short[] data)", "public void copy2DRangeTo(int xoff, int yoff, int w, int h, int[] data)", "public void copy2DRangeTo(int xoff, int yoff, int w, int h, float[] data)", "private void copy3DRangeToUnchecked(int xoff, int yoff, int zoff, int w, int h, int d, Object array, Element.DataType dt, int arrayLen)", "public void copy3DRangeTo(int xoff, int yoff, int zoff, int w, int h, int d, Object array)", "public static Allocation createTyped(RenderScript rs, Type type, MipmapControl mips, int usage)", "public static Allocation createTyped(RenderScript rs, Type type, int usage)", "public static Allocation createTyped(RenderScript rs, Type type)", "public static Allocation createSized(RenderScript rs, Element e, int count, int usage)", "public static Allocation createSized(RenderScript rs, Element e, int count)", " static Element elementFromBitmap(RenderScript rs, Bitmap b)", " static Type typeFromBitmap(RenderScript rs, Bitmap b, MipmapControl mip)", "public static Allocation createFromBitmap(RenderScript rs, Bitmap b, MipmapControl mips, int usage)", "public ByteBuffer getByteBuffer()", "public static Allocation[] createAllocations(RenderScript rs, Type t, int usage, int numAlloc)", " static Allocation createFromAllocation(RenderScript rs, Allocation alloc)", " void setupBufferQueue(int numAlloc)", " void shareBufferQueue(Allocation alloc)", "public long getStride()", "public long getTimeStamp()", "public Surface getSurface()", "public void setSurface(Surface sur)", "public static Allocation createFromBitmap(RenderScript rs, Bitmap b)", "public static Allocation createCubemapFromBitmap(RenderScript rs, Bitmap b, MipmapControl mips, int usage)", "public static Allocation createCubemapFromBitmap(RenderScript rs, Bitmap b)", "public static Allocation createCubemapFromCubeFaces(RenderScript rs, Bitmap xpos, Bitmap xneg, Bitmap ypos, Bitmap yneg, Bitmap zpos, Bitmap zneg, MipmapControl mips, int usage)", "public static Allocation createCubemapFromCubeFaces(RenderScript rs, Bitmap xpos, Bitmap xneg, Bitmap ypos, Bitmap yneg, Bitmap zpos, Bitmap zneg)", "public static Allocation createFromBitmapResource(RenderScript rs, Resources res, int id, MipmapControl mips, int usage)", "public static Allocation createFromBitmapResource(RenderScript rs, Resources res, int id)", "public static Allocation createFromString(RenderScript rs, String str, int usage)", "public void setOnBufferAvailableListener(OnBufferAvailableListener callback)", " static void sendBufferNotification(long id)", "public void destroy()" ],
  "variableNames" : [ "MAX_NUMBER_IO_INPUT_ALLOC", "mType", "mOwningType", "mBitmap", "mUsage", "mAdaptedAllocation", "mSize", "mMipmapControl", "mTimeStamp", "mReadAllowed", "mWriteAllowed", "mAutoPadding", "mSelectedX", "mSelectedY", "mSelectedZ", "mSelectedLOD", "mSelectedArray", "mSelectedFace", "mCurrentDimX", "mCurrentDimY", "mCurrentDimZ", "mCurrentCount", "mAllocationMap", "mBufferNotifier", "mGetSurfaceSurface", "mByteBuffer", "mByteBufferStride", "USAGE_SCRIPT", "USAGE_GRAPHICS_TEXTURE", "USAGE_GRAPHICS_VERTEX", "USAGE_GRAPHICS_CONSTANTS", "USAGE_GRAPHICS_RENDER_TARGET", "USAGE_IO_INPUT", "USAGE_IO_OUTPUT", "USAGE_SHARED", "mBitmapOptions" ]
}