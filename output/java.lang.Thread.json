{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/Thread.java",
  "packageName" : "java.lang",
  "className" : "Thread",
  "comment" : "\n * A <i>thread</i> is a thread of execution in a program. The Java\n * Virtual Machine allows an application to have multiple threads of\n * execution running concurrently.\n * <p>\n * Every thread has a priority. Threads with higher priority are\n * executed in preference to threads with lower priority. Each thread\n * may or may not also be marked as a daemon. When code running in\n * some thread creates a new {@code Thread} object, the new\n * thread has its priority initially set equal to the priority of the\n * creating thread, and is a daemon thread if and only if the\n * creating thread is a daemon.\n * <p>\n * When a Java Virtual Machine starts up, there is usually a single\n * non-daemon thread (which typically calls the method named\n * {@code main} of some designated class). The Java Virtual\n * Machine continues to execute threads until either of the following\n * occurs:\n * <ul>\n * <li>The {@code exit} method of class {@code Runtime} has been\n *     called and the security manager has permitted the exit operation\n *     to take place.\n * <li>All threads that are not daemon threads have died, either by\n *     returning from the call to the {@code run} method or by\n *     throwing an exception that propagates beyond the {@code run}\n *     method.\n * </ul>\n * <p>\n * There are two ways to create a new thread of execution. One is to\n * declare a class to be a subclass of {@code Thread}. This\n * subclass should override the {@code run} method of class\n * {@code Thread}. An instance of the subclass can then be\n * allocated and started. For example, a thread that computes primes\n * larger than a stated value could be written as follows:\n * <hr><blockquote><pre>\n *     class PrimeThread extends Thread {\n *         long minPrime;\n *         PrimeThread(long minPrime) {\n *             this.minPrime = minPrime;\n *         }\n *\n *         public void run() {\n *             // compute primes larger than minPrime\n *             &nbsp;.&nbsp;.&nbsp;.\n *         }\n *     }\n * </pre></blockquote><hr>\n * <p>\n * The following code would then create a thread and start it running:\n * <blockquote><pre>\n *     PrimeThread p = new PrimeThread(143);\n *     p.start();\n * </pre></blockquote>\n * <p>\n * The other way to create a thread is to declare a class that\n * implements the {@code Runnable} interface. That class then\n * implements the {@code run} method. An instance of the class can\n * then be allocated, passed as an argument when creating\n * {@code Thread}, and started. The same example in this other\n * style looks like the following:\n * <hr><blockquote><pre>\n *     class PrimeRun implements Runnable {\n *         long minPrime;\n *         PrimeRun(long minPrime) {\n *             this.minPrime = minPrime;\n *         }\n *\n *         public void run() {\n *             // compute primes larger than minPrime\n *             &nbsp;.&nbsp;.&nbsp;.\n *         }\n *     }\n * </pre></blockquote><hr>\n * <p>\n * The following code would then create a thread and start it running:\n * <blockquote><pre>\n *     PrimeRun p = new PrimeRun(143);\n *     new Thread(p).start();\n * </pre></blockquote>\n * <p>\n * Every thread has a name for identification purposes. More than\n * one thread may have the same name. If a name is not specified when\n * a thread is created, a new name is generated for it.\n * <p>\n * Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * @author  unascribed\n * @see     Runnable\n * @see     Runtime#exit(int)\n * @see     #run()\n * @see     #stop()\n * @since   1.0\n ",
  "links" : [ "java.lang.NullPointerException" ],
  "variables" : [ {
    "name" : "lock",
    "type" : "Object",
    "comment" : "\n     * The synchronization object responsible for this thread's join/sleep/park operations.\n     ",
    "links" : [ ]
  }, {
    "name" : "nativePeer",
    "type" : "long",
    "comment" : "\n     * Reference to the native thread object.\n     *\n     * <p>Is 0 if the native thread has not yet been created/started, or has been destroyed.\n     ",
    "links" : [ ]
  }, {
    "name" : "name",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "priority",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "single_step",
    "type" : "boolean",
    "comment" : " Whether or not to single_step this thread. ",
    "links" : [ ]
  }, {
    "name" : "daemon",
    "type" : "boolean",
    "comment" : " Whether or not the thread is a daemon thread. ",
    "links" : [ ]
  }, {
    "name" : "stillborn",
    "type" : "boolean",
    "comment" : " Fields reserved for exclusive use by the JVM ",
    "links" : [ ]
  }, {
    "name" : "eetop",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "target",
    "type" : "Runnable",
    "comment" : " What will be run. ",
    "links" : [ ]
  }, {
    "name" : "group",
    "type" : "ThreadGroup",
    "comment" : " The group of this thread ",
    "links" : [ ]
  }, {
    "name" : "contextClassLoader",
    "type" : "ClassLoader",
    "comment" : " The context ClassLoader for this thread ",
    "links" : [ ]
  }, {
    "name" : "inheritedAccessControlContext",
    "type" : "AccessControlContext",
    "comment" : " The inherited AccessControlContext of this thread ",
    "links" : [ ]
  }, {
    "name" : "threadInitNumber",
    "type" : "int",
    "comment" : " For autonumbering anonymous threads. ",
    "links" : [ ]
  }, {
    "name" : "threadLocals",
    "type" : "ThreadLocal.ThreadLocalMap",
    "comment" : " ThreadLocal values pertaining to this thread. This map is maintained\n     * by the ThreadLocal class. ",
    "links" : [ ]
  }, {
    "name" : "inheritableThreadLocals",
    "type" : "ThreadLocal.ThreadLocalMap",
    "comment" : "\n     * InheritableThreadLocal values pertaining to this thread. This map is\n     * maintained by the InheritableThreadLocal class.\n     ",
    "links" : [ ]
  }, {
    "name" : "stackSize",
    "type" : "long",
    "comment" : "\n     * The requested stack size for this thread, or 0 if the creator did\n     * not specify a stack size.  It is up to the VM to do whatever it\n     * likes with this number; some VMs will ignore it.\n     ",
    "links" : [ ]
  }, {
    "name" : "unparkedBeforeStart",
    "type" : "boolean",
    "comment" : "\n     * Indicates whether this thread was unpark()ed while not alive, in which case start()ing\n     * it should leave it in unparked state. This field is read and written by native code in\n     * the runtime, guarded by thread_list_lock. See http://b/28845097#comment49\n     ",
    "links" : [ ]
  }, {
    "name" : "tid",
    "type" : "long",
    "comment" : "\n     * Thread ID\n     ",
    "links" : [ ]
  }, {
    "name" : "threadSeqNumber",
    "type" : "long",
    "comment" : " For generating thread ID ",
    "links" : [ ]
  }, {
    "name" : "systemDaemon",
    "type" : "boolean",
    "comment" : " True if this thread is managed by {@link Daemons}. ",
    "links" : [ "java.lang.Daemons" ]
  }, {
    "name" : "started",
    "type" : "boolean",
    "comment" : "\n     * True if the the Thread has been started, even it has since been stopped.\n     ",
    "links" : [ ]
  }, {
    "name" : "parkBlocker",
    "type" : "Object",
    "comment" : "\n     * The argument supplied to the current call to\n     * java.util.concurrent.locks.LockSupport.park.\n     * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker\n     * Accessed using java.util.concurrent.locks.LockSupport.getBlocker\n     ",
    "links" : [ ]
  }, {
    "name" : "blocker",
    "type" : "Interruptible",
    "comment" : " The object in which this thread is blocked in an interruptible I/O\n     * operation, if any.  The blocker's interrupt method should be invoked\n     * after setting this thread's interrupt status.\n     ",
    "links" : [ ]
  }, {
    "name" : "blockerLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIN_PRIORITY",
    "type" : "int",
    "comment" : "\n     * The minimum priority that a thread can have.\n     ",
    "links" : [ ]
  }, {
    "name" : "NORM_PRIORITY",
    "type" : "int",
    "comment" : "\n     * The default priority that is assigned to a thread.\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_PRIORITY",
    "type" : "int",
    "comment" : "\n     * The maximum priority that a thread can have.\n     ",
    "links" : [ ]
  }, {
    "name" : "EMPTY_STACK_TRACE",
    "type" : "StackTraceElement[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUBCLASS_IMPLEMENTATION_PERMISSION",
    "type" : "RuntimePermission",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "uncaughtExceptionHandler",
    "type" : "UncaughtExceptionHandler",
    "comment" : " null unless explicitly set",
    "links" : [ ]
  }, {
    "name" : "defaultUncaughtExceptionHandler",
    "type" : "UncaughtExceptionHandler",
    "comment" : " null unless explicitly set",
    "links" : [ ]
  }, {
    "name" : "uncaughtExceptionPreHandler",
    "type" : "UncaughtExceptionHandler",
    "comment" : " null unless explicitly set",
    "links" : [ ]
  }, {
    "name" : "threadLocalRandomSeed",
    "type" : "long",
    "comment" : " The current seed for a ThreadLocalRandom ",
    "links" : [ ]
  }, {
    "name" : "threadLocalRandomProbe",
    "type" : "int",
    "comment" : " Probe hash value; nonzero if threadLocalRandomSeed initialized ",
    "links" : [ ]
  }, {
    "name" : "threadLocalRandomSecondarySeed",
    "type" : "int",
    "comment" : " Secondary seed isolated from public ThreadLocalRandom sequence ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static synchronized int nextThreadNum()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static synchronized long nextThreadID()",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void blockedOn(Interruptible b)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static native Thread currentThread()",
    "returnType" : "Thread",
    "comment" : "\n     * Returns a reference to the currently executing thread object.\n     *\n     * @return  the currently executing thread.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native void yield()",
    "returnType" : "void",
    "comment" : "\n     * A hint to the scheduler that the current thread is willing to yield\n     * its current use of a processor. The scheduler is free to ignore this\n     * hint.\n     *\n     * <p> Yield is a heuristic attempt to improve relative progression\n     * between threads that would otherwise over-utilise a CPU. Its use\n     * should be combined with detailed profiling and benchmarking to\n     * ensure that it actually has the desired effect.\n     *\n     * <p> It is rarely appropriate to use this method. It may be useful\n     * for debugging or testing purposes, where it may help to reproduce\n     * bugs due to race conditions. It may also be useful when designing\n     * concurrency control constructs such as the ones in the\n     * {@link java.util.concurrent.locks} package.\n     ",
    "links" : [ "java.util.concurrent.locks" ]
  }, {
    "name" : "public static void sleep(long millis) throws InterruptedException",
    "returnType" : "void",
    "comment" : " BEGIN Android-changed: Implement sleep() methods using a shared native implementation.",
    "links" : [ ]
  }, {
    "name" : "private static native void sleep(Object lock, long millis, int nanos) throws InterruptedException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void sleep(long millis, int nanos) throws InterruptedException",
    "returnType" : "void",
    "comment" : "\n     * Causes the currently executing thread to sleep (temporarily cease\n     * execution) for the specified number of milliseconds plus the specified\n     * number of nanoseconds, subject to the precision and accuracy of system\n     * timers and schedulers. The thread does not lose ownership of any\n     * monitors.\n     *\n     * @param  millis\n     *         the length of time to sleep in milliseconds\n     *\n     * @param  nanos\n     *         {@code 0-999999} additional nanoseconds to sleep\n     *\n     * @throws  IllegalArgumentException\n     *          if the value of {@code millis} is negative, or the value of\n     *          {@code nanos} is not in the range {@code 0-999999}\n     *\n     * @throws  InterruptedException\n     *          if any thread has interrupted the current thread. The\n     *          <i>interrupted status</i> of the current thread is\n     *          cleared when this exception is thrown.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void onSpinWait()",
    "returnType" : "void",
    "comment" : "\n     * Indicates that the caller is momentarily unable to progress, until the\n     * occurrence of one or more actions on the part of other activities. By\n     * invoking this method within each iteration of a spin-wait loop construct,\n     * the calling thread indicates to the runtime that it is busy-waiting.\n     * The runtime may take action to improve the performance of invoking\n     * spin-wait loop constructions.\n     *\n     * @apiNote\n     * As an example consider a method in a class that spins in a loop until\n     * some flag is set outside of that method. A call to the {@code onSpinWait}\n     * method should be placed inside the spin loop.\n     * <pre>{@code\n     *     class EventHandler {\n     *         volatile boolean eventNotificationNotReceived;\n     *         void waitForEventAndHandleIt() {\n     *             while ( eventNotificationNotReceived ) {\n     *                 java.lang.Thread.onSpinWait();\n     *             }\n     *             readAndProcessEvent();\n     *         }\n     *\n     *         void readAndProcessEvent() {\n     *             // Read event from some source and process it\n     *              . . .\n     *         }\n     *     }\n     * }</pre>\n     * <p>\n     * The code above would remain correct even if the {@code onSpinWait}\n     * method was not called at all. However on some architectures the Java\n     * Virtual Machine may issue the processor instructions to address such\n     * code patterns in a more beneficial way.\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "protected Object clone() throws CloneNotSupportedException",
    "returnType" : "Object",
    "comment" : "\n     * Throws CloneNotSupportedException as a Thread can not be meaningfully\n     * cloned. Construct a new Thread instead.\n     *\n     * @throws  CloneNotSupportedException\n     *          always\n     ",
    "links" : [ ]
  }, {
    "name" : "private void init2(Thread parent, boolean inheritThreadLocals)",
    "returnType" : "void",
    "comment" : " Android-added: Helper method for previous constructor and init(...) method.",
    "links" : [ ]
  }, {
    "name" : "public synchronized void start()",
    "returnType" : "void",
    "comment" : "\n     * Causes this thread to begin execution; the Java Virtual Machine\n     * calls the {@code run} method of this thread.\n     * <p>\n     * The result is that two threads are running concurrently: the\n     * current thread (which returns from the call to the\n     * {@code start} method) and the other thread (which executes its\n     * {@code run} method).\n     * <p>\n     * It is never legal to start a thread more than once.\n     * In particular, a thread may not be restarted once it has completed\n     * execution.\n     *\n     * @throws     IllegalThreadStateException  if the thread was already started.\n     * @see        #run()\n     * @see        #stop()\n     ",
    "links" : [ ]
  }, {
    "name" : "private static native void nativeCreate(Thread t, long stackSize, boolean daemon)",
    "returnType" : "void",
    "comment" : " private native void start0();",
    "links" : [ ]
  }, {
    "name" : "public void run()",
    "returnType" : "void",
    "comment" : "\n     * If this thread was constructed using a separate\n     * {@code Runnable} run object, then that\n     * {@code Runnable} object's {@code run} method is called;\n     * otherwise, this method does nothing and returns.\n     * <p>\n     * Subclasses of {@code Thread} should override this method.\n     *\n     * @see     #start()\n     * @see     #stop()\n     * @see     #Thread(ThreadGroup, Runnable, String)\n     ",
    "links" : [ ]
  }, {
    "name" : "private void exit()",
    "returnType" : "void",
    "comment" : "\n     * This method is called by the system to give a Thread\n     * a chance to clean up before it actually exits.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void stop()",
    "returnType" : "void",
    "comment" : "\n     * Throws {@code UnsupportedOperationException}.\n     *\n     * @deprecated This method was originally designed to force a thread to stop\n     *       and throw a {@code ThreadDeath} as an exception. It was inherently unsafe.\n     *       Stopping a thread with\n     *       Thread.stop causes it to unlock all of the monitors that it\n     *       has locked (as a natural consequence of the unchecked\n     *       {@code ThreadDeath} exception propagating up the stack).  If\n     *       any of the objects previously protected by these monitors were in\n     *       an inconsistent state, the damaged objects become visible to\n     *       other threads, potentially resulting in arbitrary behavior.  Many\n     *       uses of {@code stop} should be replaced by code that simply\n     *       modifies some variable to indicate that the target thread should\n     *       stop running.  The target thread should check this variable\n     *       regularly, and return from its run method in an orderly fashion\n     *       if the variable indicates that it is to stop running.  If the\n     *       target thread waits for long periods (on a condition variable,\n     *       for example), the {@code interrupt} method should be used to\n     *       interrupt the wait.\n     *       For more information, see\n     *       <a href=\"{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html\">Why\n     *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final synchronized void stop(Throwable obj)",
    "returnType" : "void",
    "comment" : "\n     * Throws {@code UnsupportedOperationException}.\n     *\n     * @param obj ignored\n     *\n     * @deprecated This method was originally designed to force a thread to stop\n     *        and throw a given {@code Throwable} as an exception. It was\n     *        inherently unsafe (see {@link #stop()} for details), and furthermore\n     *        could be used to generate exceptions that the target thread was\n     *        not prepared to handle.\n     *        For more information, see\n     *        <a href=\"{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html\">Why\n     *        are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.\n     ",
    "links" : [ "#stop()" ]
  }, {
    "name" : "public void interrupt()",
    "returnType" : "void",
    "comment" : "\n     * Interrupts this thread.\n     *\n     * <p> Unless the current thread is interrupting itself, which is\n     * always permitted, the {@link #checkAccess() checkAccess} method\n     * of this thread is invoked, which may cause a {@link\n     * SecurityException} to be thrown.\n     *\n     * <p> If this thread is blocked in an invocation of the {@link\n     * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link\n     * Object#wait(long, int) wait(long, int)} methods of the {@link Object}\n     * class, or of the {@link #join()}, {@link #join(long)}, {@link\n     * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)},\n     * methods of this class, then its interrupt status will be cleared and it\n     * will receive an {@link InterruptedException}.\n     *\n     * <p> If this thread is blocked in an I/O operation upon an {@link\n     * java.nio.channels.InterruptibleChannel InterruptibleChannel}\n     * then the channel will be closed, the thread's interrupt\n     * status will be set, and the thread will receive a {@link\n     * java.nio.channels.ClosedByInterruptException}.\n     *\n     * <p> If this thread is blocked in a {@link java.nio.channels.Selector}\n     * then the thread's interrupt status will be set and it will return\n     * immediately from the selection operation, possibly with a non-zero\n     * value, just as if the selector's {@link\n     * java.nio.channels.Selector#wakeup wakeup} method were invoked.\n     *\n     * <p> If none of the previous conditions hold then this thread's interrupt\n     * status will be set. </p>\n     *\n     * <p> Interrupting a thread that is not alive need not have any effect.\n     *\n     * @throws  SecurityException\n     *          if the current thread cannot modify this thread\n     *\n     * @revised 6.0\n     * @spec JSR-51\n     ",
    "links" : [ "#sleep(long)", "#sleep(long", "#checkAccess()", "java.lang.Object#wait(long)", "#join()", "java.nio.channels.Selector", "java.nio.channels.Selector#wakeup", "java.lang.Object#wait()", "java.nio.channels.ClosedByInterruptException", "java.nio.channels.InterruptibleChannel", "java.lang.Object#wait(long", "java.lang.InterruptedException", "#join(long)", "java.lang.SecurityException", "java.lang.Object", "#join(long" ]
  }, {
    "name" : "public static native boolean interrupted()",
    "returnType" : "boolean",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public native boolean isInterrupted()",
    "returnType" : "boolean",
    "comment" : " }",
    "links" : [ ]
  }, {
    "name" : "public void destroy()",
    "returnType" : "void",
    "comment" : "\n     * Throws {@link UnsupportedOperationException}.\n     *\n     * @deprecated This method was originally designed to destroy this\n     *     thread without any cleanup. Any monitors it held would have\n     *     remained locked. However, the method was never implemented.\n     *     If if were to be implemented, it would be deadlock-prone in\n     *     much the manner of {@link #suspend}. If the target thread held\n     *     a lock protecting a critical system resource when it was\n     *     destroyed, no thread could ever access this resource again.\n     *     If another thread ever attempted to lock this resource, deadlock\n     *     would result. Such deadlocks typically manifest themselves as\n     *     \"frozen\" processes. For more information, see\n     *     <a href=\"{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html\">\n     *     Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.\n     * @throws UnsupportedOperationException always\n     ",
    "links" : [ "java.lang.UnsupportedOperationException", "#suspend" ]
  }, {
    "name" : "public final boolean isAlive()",
    "returnType" : "boolean",
    "comment" : " public final native boolean isAlive();",
    "links" : [ ]
  }, {
    "name" : "public final void suspend()",
    "returnType" : "void",
    "comment" : "\n     * Throws {@link UnsupportedOperationException}.\n     *\n     * @deprecated   This method has been deprecated, as it is\n     *   inherently deadlock-prone.  If the target thread holds a lock on the\n     *   monitor protecting a critical system resource when it is suspended, no\n     *   thread can access this resource until the target thread is resumed. If\n     *   the thread that would resume the target thread attempts to lock this\n     *   monitor prior to calling {@code resume}, deadlock results.  Such\n     *   deadlocks typically manifest themselves as \"frozen\" processes.\n     *   For more information, see\n     *   <a href=\"{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html\">Why\n     *   are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.\n     * @throws UnsupportedOperationException always\n     ",
    "links" : [ "java.lang.UnsupportedOperationException" ]
  }, {
    "name" : "public final void resume()",
    "returnType" : "void",
    "comment" : "\n     * Throws {@link UnsupportedOperationException}.\n     *\n     * @deprecated This method exists solely for use with {@link #suspend},\n     *     which has been deprecated because it is deadlock-prone.\n     *     For more information, see\n     *     <a href=\"{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html\">Why\n     *     are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.\n     * @throws UnsupportedOperationException always\n     ",
    "links" : [ "java.lang.UnsupportedOperationException", "#suspend" ]
  }, {
    "name" : "public final void setPriority(int newPriority)",
    "returnType" : "void",
    "comment" : "\n     * Changes the priority of this thread.\n     * <p>\n     * First the {@code checkAccess} method of this thread is called\n     * with no arguments. This may result in throwing a {@code SecurityException}.\n     * <p>\n     * Otherwise, the priority of this thread is set to the smaller of\n     * the specified {@code newPriority} and the maximum permitted\n     * priority of the thread's thread group.\n     *\n     * @param newPriority priority to set this thread to\n     * @throws     IllegalArgumentException  If the priority is not in the\n     *               range {@code MIN_PRIORITY} to\n     *               {@code MAX_PRIORITY}.\n     * @throws     SecurityException  if the current thread cannot modify\n     *               this thread.\n     * @see        #getPriority\n     * @see        #checkAccess()\n     * @see        #getThreadGroup()\n     * @see        #MAX_PRIORITY\n     * @see        #MIN_PRIORITY\n     * @see        ThreadGroup#getMaxPriority()\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getPriority()",
    "returnType" : "int",
    "comment" : "\n     * Returns this thread's priority.\n     *\n     * @return  this thread's priority.\n     * @see     #setPriority\n     ",
    "links" : [ ]
  }, {
    "name" : "public final synchronized void setName(String name)",
    "returnType" : "void",
    "comment" : "\n     * Changes the name of this thread to be equal to the argument {@code name}.\n     * <p>\n     * First the {@code checkAccess} method of this thread is called\n     * with no arguments. This may result in throwing a\n     * {@code SecurityException}.\n     *\n     * @param      name   the new name for this thread.\n     * @throws     SecurityException  if the current thread cannot modify this\n     *             thread.\n     * @see        #getName\n     * @see        #checkAccess()\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getName()",
    "returnType" : "String",
    "comment" : "\n     * Returns this thread's name.\n     *\n     * @return  this thread's name.\n     * @see     #setName(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "public final ThreadGroup getThreadGroup()",
    "returnType" : "ThreadGroup",
    "comment" : "\n     * Returns the thread group to which this thread belongs.\n     * This method returns null if this thread has died\n     * (been stopped).\n     *\n     * @return  this thread's thread group.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int activeCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns an estimate of the number of active threads in the current\n     * thread's {@linkplain java.lang.ThreadGroup thread group} and its\n     * subgroups. Recursively iterates over all subgroups in the current\n     * thread's thread group.\n     *\n     * <p> The value returned is only an estimate because the number of\n     * threads may change dynamically while this method traverses internal\n     * data structures, and might be affected by the presence of certain\n     * system threads. This method is intended primarily for debugging\n     * and monitoring purposes.\n     *\n     * @return  an estimate of the number of active threads in the current\n     *          thread's thread group and in any other thread group that\n     *          has the current thread's thread group as an ancestor\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int enumerate(Thread[] tarray)",
    "returnType" : "int",
    "comment" : "\n     * Copies into the specified array every active thread in the current\n     * thread's thread group and its subgroups. This method simply\n     * invokes the {@link java.lang.ThreadGroup#enumerate(Thread[])}\n     * method of the current thread's thread group.\n     *\n     * <p> An application might use the {@linkplain #activeCount activeCount}\n     * method to get an estimate of how big the array should be, however\n     * <i>if the array is too short to hold all the threads, the extra threads\n     * are silently ignored.</i>  If it is critical to obtain every active\n     * thread in the current thread's thread group and its subgroups, the\n     * invoker should verify that the returned int value is strictly less\n     * than the length of {@code tarray}.\n     *\n     * <p> Due to the inherent race condition in this method, it is recommended\n     * that the method only be used for debugging and monitoring purposes.\n     *\n     * @param  tarray\n     *         an array into which to put the list of threads\n     *\n     * @return  the number of threads put into the array\n     *\n     * @throws  SecurityException\n     *          if {@link java.lang.ThreadGroup#checkAccess} determines that\n     *          the current thread cannot access its thread group\n     ",
    "links" : [ "java.lang.ThreadGroup#checkAccess", "java.lang.ThreadGroup#enumerate(Thread" ]
  }, {
    "name" : "public int countStackFrames()",
    "returnType" : "int",
    "comment" : "\n     * Counts the number of stack frames in this thread. The thread must\n     * be suspended.\n     *\n     * @return     the number of stack frames in this thread.\n     * @throws     IllegalThreadStateException  if this thread is not\n     *             suspended.\n     * @deprecated The definition of this call depends on {@link #suspend},\n     *             which is deprecated.  Further, the results of this call\n     *             were never well-defined.\n     *             This method is subject to removal in a future version of Java SE.\n     ",
    "links" : [ "#suspend" ]
  }, {
    "name" : "public final void join(long millis) throws InterruptedException",
    "returnType" : "void",
    "comment" : " public final synchronized void join(long millis)",
    "links" : [ ]
  }, {
    "name" : "public final void join(long millis, int nanos) throws InterruptedException",
    "returnType" : "void",
    "comment" : " public final synchronized void join(long millis, int nanos)",
    "links" : [ ]
  }, {
    "name" : "public final void join() throws InterruptedException",
    "returnType" : "void",
    "comment" : "\n     * Waits for this thread to die.\n     *\n     * <p> An invocation of this method behaves in exactly the same\n     * way as the invocation\n     *\n     * <blockquote>\n     * {@linkplain #join(long) join}{@code (0)}\n     * </blockquote>\n     *\n     * @throws  InterruptedException\n     *          if any thread has interrupted the current thread. The\n     *          <i>interrupted status</i> of the current thread is\n     *          cleared when this exception is thrown.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void dumpStack()",
    "returnType" : "void",
    "comment" : "\n     * Prints a stack trace of the current thread to the standard error stream.\n     * This method is used only for debugging.\n     *\n     * @see     Throwable#printStackTrace()\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setDaemon(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * Marks this thread as either a {@linkplain #isDaemon daemon} thread\n     * or a user thread. The Java Virtual Machine exits when the only\n     * threads running are all daemon threads.\n     *\n     * <p> This method must be invoked before the thread is started.\n     *\n     * @param  on\n     *         if {@code true}, marks this thread as a daemon thread\n     *\n     * @throws  IllegalThreadStateException\n     *          if this thread is {@linkplain #isAlive alive}\n     *\n     * @throws  SecurityException\n     *          if {@link #checkAccess} determines that the current\n     *          thread cannot modify this thread\n     ",
    "links" : [ "#checkAccess" ]
  }, {
    "name" : "public final boolean isDaemon()",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if this thread is a daemon thread.\n     *\n     * @return  {@code true} if this thread is a daemon thread;\n     *          {@code false} otherwise.\n     * @see     #setDaemon(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void checkAccess()",
    "returnType" : "void",
    "comment" : "\n     * Determines if the currently running thread has permission to\n     * modify this thread.\n     * <p>\n     * If there is a security manager, its {@code checkAccess} method\n     * is called with this thread as its argument. This may result in\n     * throwing a {@code SecurityException}.\n     *\n     * @throws  SecurityException  if the current thread is not allowed to\n     *          access this thread.\n     * @see        SecurityManager#checkAccess(Thread)\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of this thread, including the\n     * thread's name, priority, and thread group.\n     *\n     * @return  a string representation of this thread.\n     ",
    "links" : [ ]
  }, {
    "name" : "public ClassLoader getContextClassLoader()",
    "returnType" : "ClassLoader",
    "comment" : "\n     * Returns the context {@code ClassLoader} for this thread. The context\n     * {@code ClassLoader} is provided by the creator of the thread for use\n     * by code running in this thread when loading classes and resources.\n     * If not {@linkplain #setContextClassLoader set}, the default is the\n     * {@code ClassLoader} context of the parent thread. The context\n     * {@code ClassLoader} of the\n     * primordial thread is typically set to the class loader used to load the\n     * application.\n     *\n     *\n     * @return  the context {@code ClassLoader} for this thread, or {@code null}\n     *          indicating the system class loader (or, failing that, the\n     *          bootstrap class loader)\n     *\n     * @throws  SecurityException\n     *          if the current thread cannot get the context ClassLoader\n     *\n     * @since 1.2\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setContextClassLoader(ClassLoader cl)",
    "returnType" : "void",
    "comment" : "\n     * Sets the context ClassLoader for this Thread. The context\n     * ClassLoader can be set when a thread is created, and allows\n     * the creator of the thread to provide the appropriate class loader,\n     * through {@code getContextClassLoader}, to code running in the thread\n     * when loading classes and resources.\n     *\n     * <p>If a security manager is present, its {@link\n     * SecurityManager#checkPermission(java.security.Permission) checkPermission}\n     * method is invoked with a {@link RuntimePermission RuntimePermission}{@code\n     * (\"setContextClassLoader\")} permission to see if setting the context\n     * ClassLoader is permitted.\n     *\n     * @param  cl\n     *         the context ClassLoader for this Thread, or null  indicating the\n     *         system class loader (or, failing that, the bootstrap class loader)\n     *\n     * @throws  SecurityException\n     *          if the current thread cannot set the context ClassLoader\n     *\n     * @since 1.2\n     ",
    "links" : [ "java.lang.SecurityManager#checkPermission(java.security.Permission)", "java.lang.RuntimePermission" ]
  }, {
    "name" : "public static native boolean holdsLock(Object obj)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if and only if the current thread holds the\n     * monitor lock on the specified object.\n     *\n     * <p>This method is designed to allow a program to assert that\n     * the current thread already holds a specified lock:\n     * <pre>\n     *     assert Thread.holdsLock(obj);\n     * </pre>\n     *\n     * @param  obj the object on which to test lock ownership\n     * @throws NullPointerException if obj is {@code null}\n     * @return {@code true} if the current thread holds the monitor lock on\n     *         the specified object.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "public StackTraceElement[] getStackTrace()",
    "returnType" : "StackTraceElement[]",
    "comment" : "\n     * Returns an array of stack trace elements representing the stack dump\n     * of this thread.  This method will return a zero-length array if\n     * this thread has not started, has started but has not yet been\n     * scheduled to run by the system, or has terminated.\n     * If the returned array is of non-zero length then the first element of\n     * the array represents the top of the stack, which is the most recent\n     * method invocation in the sequence.  The last element of the array\n     * represents the bottom of the stack, which is the least recent method\n     * invocation in the sequence.\n     *\n     * <p>If there is a security manager, and this thread is not\n     * the current thread, then the security manager's\n     * {@code checkPermission} method is called with a\n     * {@code RuntimePermission(\"getStackTrace\")} permission\n     * to see if it's ok to get the stack trace.\n     *\n     * <p>Some virtual machines may, under some circumstances, omit one\n     * or more stack frames from the stack trace.  In the extreme case,\n     * a virtual machine that has no stack trace information concerning\n     * this thread is permitted to return a zero-length array from this\n     * method.\n     *\n     * @return an array of {@code StackTraceElement},\n     * each represents one stack frame.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn't allow\n     *        getting the stack trace of thread.\n     * @see SecurityManager#checkPermission\n     * @see RuntimePermission\n     * @see Throwable#getStackTrace\n     *\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Map<Thread, StackTraceElement[]> getAllStackTraces()",
    "returnType" : "Map<Thread, StackTraceElement[]>",
    "comment" : "\n     * Returns a map of stack traces for all live threads.\n     * The map keys are threads and each map value is an array of\n     * {@code StackTraceElement} that represents the stack dump\n     * of the corresponding {@code Thread}.\n     * The returned stack traces are in the format specified for\n     * the {@link #getStackTrace getStackTrace} method.\n     *\n     * <p>The threads may be executing while this method is called.\n     * The stack trace of each thread only represents a snapshot and\n     * each stack trace may be obtained at different time.  A zero-length\n     * array will be returned in the map value if the virtual machine has\n     * no stack trace information about a thread.\n     *\n     * @return a {@code Map} from {@code Thread} to an array of\n     * {@code StackTraceElement} that represents the stack trace of\n     * the corresponding thread.\n     *\n     * @see #getStackTrace\n     * @see SecurityManager#checkPermission\n     * @see RuntimePermission\n     * @see Throwable#getStackTrace\n     *\n     * @since 1.5\n     ",
    "links" : [ "#getStackTrace" ]
  }, {
    "name" : "private static boolean isCCLOverridden(Class<?> cl)",
    "returnType" : "boolean",
    "comment" : "\n     * Verifies that this (possibly subclass) instance can be constructed\n     * without violating security constraints: the subclass must not override\n     * security-sensitive non-final methods, or else the\n     * \"enableContextClassLoaderOverride\" RuntimePermission is checked.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean auditSubclass(final Class<?> subcl)",
    "returnType" : "boolean",
    "comment" : "\n     * Performs reflective checks on given subclass to verify that it doesn't\n     * override security-sensitive non-final methods.  Returns true if the\n     * subclass overrides any of the methods, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getId()",
    "returnType" : "long",
    "comment" : "\n     * Returns the identifier of this Thread.  The thread ID is a positive\n     * {@code long} number generated when this thread was created.\n     * The thread ID is unique and remains unchanged during its lifetime.\n     * When a thread is terminated, this thread ID may be reused.\n     *\n     * @return this thread's ID.\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public State getState()",
    "returnType" : "State",
    "comment" : "\n     * Returns the state of this thread.\n     * This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     *\n     * @return this thread's state.\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)",
    "returnType" : "void",
    "comment" : "\n     * Set the default handler invoked when a thread abruptly terminates\n     * due to an uncaught exception, and no other handler has been defined\n     * for that thread.\n     *\n     * <p>Uncaught exception handling is controlled first by the thread, then\n     * by the thread's {@link ThreadGroup} object and finally by the default\n     * uncaught exception handler. If the thread does not have an explicit\n     * uncaught exception handler set, and the thread's thread group\n     * (including parent thread groups)  does not specialize its\n     * {@code uncaughtException} method, then the default handler's\n     * {@code uncaughtException} method will be invoked.\n     * <p>By setting the default uncaught exception handler, an application\n     * can change the way in which uncaught exceptions are handled (such as\n     * logging to a specific device, or file) for those threads that would\n     * already accept whatever &quot;default&quot; behavior the system\n     * provided.\n     *\n     * <p>Note that the default uncaught exception handler should not usually\n     * defer to the thread's {@code ThreadGroup} object, as that could cause\n     * infinite recursion.\n     *\n     * @param eh the object to use as the default uncaught exception handler.\n     * If {@code null} then there is no default handler.\n     *\n     * @see #setUncaughtExceptionHandler\n     * @see #getUncaughtExceptionHandler\n     * @see ThreadGroup#uncaughtException\n     * @since 1.5\n     ",
    "links" : [ "java.lang.ThreadGroup" ]
  }, {
    "name" : "public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()",
    "returnType" : "UncaughtExceptionHandler",
    "comment" : "\n     * Returns the default handler invoked when a thread abruptly terminates\n     * due to an uncaught exception. If the returned value is {@code null},\n     * there is no default.\n     * @since 1.5\n     * @see #setDefaultUncaughtExceptionHandler\n     * @return the default uncaught exception handler for all threads\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setUncaughtExceptionPreHandler(UncaughtExceptionHandler eh)",
    "returnType" : "void",
    "comment" : "\n     * Sets an {@link UncaughtExceptionHandler} that will be called before any\n     * returned by {@link #getUncaughtExceptionHandler()}. To allow the standard\n     * handlers to run, this handler should never terminate this process. Any\n     * throwables thrown by the handler will be ignored by\n     * {@link #dispatchUncaughtException(Throwable)}.\n     *\n     * @hide used when configuring the runtime for exception logging; see\n     *     {@link dalvik.system.RuntimeHooks} b/29624607\n     ",
    "links" : [ "dalvik.system.RuntimeHooks", "#getUncaughtExceptionHandler()", "UncaughtExceptionHandler", "#dispatchUncaughtException(Throwable)" ]
  }, {
    "name" : "public static UncaughtExceptionHandler getUncaughtExceptionPreHandler()",
    "returnType" : "UncaughtExceptionHandler",
    "comment" : "\n     * Gets an {@link UncaughtExceptionHandler} that will be called before any\n     * returned by {@link #getUncaughtExceptionHandler()}. Can be {@code null} if\n     * was not explicitly set with\n     * {@link #setUncaughtExceptionPreHandler(UncaughtExceptionHandler)}.\n     *\n     * @return the uncaught exception prehandler for this thread\n     *\n     * @hide\n     ",
    "links" : [ "#getUncaughtExceptionHandler()", "UncaughtExceptionHandler", "#setUncaughtExceptionPreHandler(UncaughtExceptionHandler)" ]
  }, {
    "name" : "public UncaughtExceptionHandler getUncaughtExceptionHandler()",
    "returnType" : "UncaughtExceptionHandler",
    "comment" : "\n     * Returns the handler invoked when this thread abruptly terminates\n     * due to an uncaught exception. If this thread has not had an\n     * uncaught exception handler explicitly set then this thread's\n     * {@code ThreadGroup} object is returned, unless this thread\n     * has terminated, in which case {@code null} is returned.\n     * @since 1.5\n     * @return the uncaught exception handler for this thread\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh)",
    "returnType" : "void",
    "comment" : "\n     * Set the handler invoked when this thread abruptly terminates\n     * due to an uncaught exception.\n     * <p>A thread can take full control of how it responds to uncaught\n     * exceptions by having its uncaught exception handler explicitly set.\n     * If no such handler is set then the thread's {@code ThreadGroup}\n     * object acts as its handler.\n     * @param eh the object to use as this thread's uncaught exception\n     * handler. If {@code null} then this thread has no explicit handler.\n     * @throws  SecurityException  if the current thread is not allowed to\n     *          modify this thread.\n     * @see #setDefaultUncaughtExceptionHandler\n     * @see ThreadGroup#uncaughtException\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void dispatchUncaughtException(Throwable e)",
    "returnType" : "void",
    "comment" : " Android-changed: Make dispatchUncaughtException() public, for use by tests.",
    "links" : [ ]
  }, {
    "name" : " final void setSystemDaemon(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * Marks this thread as either a special runtime-managed (\"system daemon\")\n     * thread or a normal (i.e. app code created) daemon thread.)\n     *\n     * <p>System daemon threads get special handling when starting up in some\n     * cases.\n     *\n     * <p>This method must be invoked before the thread is started.\n     *\n     * <p>This method must only be invoked on Thread instances that have already\n     * had {@code setDaemon(true)} called on them.\n     *\n     * <p>Package-private since only {@link java.lang.Daemons} needs to call\n     * this.\n     *\n     * @param  on if {@code true}, marks this thread as a system daemon thread\n     *\n     * @throws  IllegalThreadStateException\n     *          if this thread is {@linkplain #isAlive alive} or not a\n     *          {@linkplain #isDaemon daemon}\n     *\n     * @throws  SecurityException\n     *          if {@link #checkAccess} determines that the current\n     *          thread cannot modify this thread\n     *\n     * @hide For use by Daemons.java only.\n     ",
    "links" : [ "java.lang.Daemons", "#checkAccess" ]
  }, {
    "name" : " static void processQueue(ReferenceQueue<Class<?>> queue, ConcurrentMap<? extends WeakReference<Class<?>>, ?> map)",
    "returnType" : "void",
    "comment" : "\n     * Removes from the specified map any keys that have been enqueued\n     * on the specified reference queue.\n     ",
    "links" : [ ]
  }, {
    "name" : " native void setPriority0(int newPriority)",
    "returnType" : "void",
    "comment" : "\n     * Android-changed: Make accessible to Daemons.java for internal use.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void interrupt0()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native void setNativeName(String name)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nativeGetStatus(boolean hasBeenStarted)",
    "returnType" : "int",
    "comment" : " Android-added: Android specific nativeGetStatus() method.",
    "links" : [ ]
  } ],
  "methodNames" : [ "private static synchronized int nextThreadNum()", "private static synchronized long nextThreadID()", "public void blockedOn(Interruptible b)", "public static native Thread currentThread()", "public static native void yield()", "public static void sleep(long millis) throws InterruptedException", "private static native void sleep(Object lock, long millis, int nanos) throws InterruptedException", "public static void sleep(long millis, int nanos) throws InterruptedException", "public static void onSpinWait()", "protected Object clone() throws CloneNotSupportedException", "private void init2(Thread parent, boolean inheritThreadLocals)", "public synchronized void start()", "private static native void nativeCreate(Thread t, long stackSize, boolean daemon)", "public void run()", "private void exit()", "public final void stop()", "public final synchronized void stop(Throwable obj)", "public void interrupt()", "public static native boolean interrupted()", "public native boolean isInterrupted()", "public void destroy()", "public final boolean isAlive()", "public final void suspend()", "public final void resume()", "public final void setPriority(int newPriority)", "public final int getPriority()", "public final synchronized void setName(String name)", "public final String getName()", "public final ThreadGroup getThreadGroup()", "public static int activeCount()", "public static int enumerate(Thread[] tarray)", "public int countStackFrames()", "public final void join(long millis) throws InterruptedException", "public final void join(long millis, int nanos) throws InterruptedException", "public final void join() throws InterruptedException", "public static void dumpStack()", "public final void setDaemon(boolean on)", "public final boolean isDaemon()", "public final void checkAccess()", "public String toString()", "public ClassLoader getContextClassLoader()", "public void setContextClassLoader(ClassLoader cl)", "public static native boolean holdsLock(Object obj)", "public StackTraceElement[] getStackTrace()", "public static Map<Thread, StackTraceElement[]> getAllStackTraces()", "private static boolean isCCLOverridden(Class<?> cl)", "private static boolean auditSubclass(final Class<?> subcl)", "public long getId()", "public State getState()", "public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)", "public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()", "public static void setUncaughtExceptionPreHandler(UncaughtExceptionHandler eh)", "public static UncaughtExceptionHandler getUncaughtExceptionPreHandler()", "public UncaughtExceptionHandler getUncaughtExceptionHandler()", "public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh)", "public final void dispatchUncaughtException(Throwable e)", " final void setSystemDaemon(boolean on)", " static void processQueue(ReferenceQueue<Class<?>> queue, ConcurrentMap<? extends WeakReference<Class<?>>, ?> map)", " native void setPriority0(int newPriority)", "private native void interrupt0()", "private native void setNativeName(String name)", "private native int nativeGetStatus(boolean hasBeenStarted)" ],
  "variableNames" : [ "lock", "nativePeer", "name", "priority", "single_step", "daemon", "stillborn", "eetop", "target", "group", "contextClassLoader", "inheritedAccessControlContext", "threadInitNumber", "threadLocals", "inheritableThreadLocals", "stackSize", "unparkedBeforeStart", "tid", "threadSeqNumber", "systemDaemon", "started", "parkBlocker", "blocker", "blockerLock", "MIN_PRIORITY", "NORM_PRIORITY", "MAX_PRIORITY", "EMPTY_STACK_TRACE", "SUBCLASS_IMPLEMENTATION_PERMISSION", "uncaughtExceptionHandler", "defaultUncaughtExceptionHandler", "uncaughtExceptionPreHandler", "threadLocalRandomSeed", "threadLocalRandomProbe", "threadLocalRandomSecondarySeed" ]
}