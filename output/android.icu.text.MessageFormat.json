{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/icu/text/MessageFormat.java",
  "packageName" : "android.icu.text",
  "className" : "MessageFormat",
  "comment" : "\n * <strong>[icu enhancement]</strong> ICU's replacement for {@link java.text.MessageFormat}.&nbsp;Methods, fields, and other functionality specific to ICU are labeled '<strong>[icu]</strong>'.\n *\n * <p>MessageFormat prepares strings for display to users,\n * with optional arguments (variables/placeholders).\n * The arguments can occur in any order, which is necessary for translation\n * into languages with different grammars.\n *\n * <p>A MessageFormat is constructed from a <em>pattern</em> string\n * with arguments in {curly braces} which will be replaced by formatted values.\n *\n * <p><code>MessageFormat</code> differs from the other <code>Format</code>\n * classes in that you create a <code>MessageFormat</code> object with one\n * of its constructors (not with a <code>getInstance</code> style factory\n * method). Factory methods aren't necessary because <code>MessageFormat</code>\n * itself doesn't implement locale-specific behavior. Any locale-specific\n * behavior is defined by the pattern that you provide and the\n * subformats used for inserted arguments.\n *\n * <p>Arguments can be named (using identifiers) or numbered (using small ASCII-digit integers).\n * Some of the API methods work only with argument numbers and throw an exception\n * if the pattern has named arguments (see {@link #usesNamedArguments()}).\n *\n * <p>An argument might not specify any format type. In this case,\n * a Number value is formatted with a default (for the locale) NumberFormat,\n * a Date value is formatted with a default (for the locale) DateFormat,\n * and for any other value its toString() value is used.\n *\n * <p>An argument might specify a \"simple\" type for which the specified\n * Format object is created, cached and used.\n *\n * <p>An argument might have a \"complex\" type with nested MessageFormat sub-patterns.\n * During formatting, one of these sub-messages is selected according to the argument value\n * and recursively formatted.\n *\n * <p>After construction, a custom Format object can be set for\n * a top-level argument, overriding the default formatting and parsing behavior\n * for that argument.\n * However, custom formatting can be achieved more simply by writing\n * a typeless argument in the pattern string\n * and supplying it with a preformatted string value.\n *\n * <p>When formatting, MessageFormat takes a collection of argument values\n * and writes an output string.\n * The argument values may be passed as an array\n * (when the pattern contains only numbered arguments)\n * or as a Map (which works for both named and numbered arguments).\n *\n * <p>Each argument is matched with one of the input values by array index or map key\n * and formatted according to its pattern specification\n * (or using a custom Format object if one was set).\n * A numbered pattern argument is matched with a map key that contains that number\n * as an ASCII-decimal-digit string (without leading zero).\n *\n * <h3><a name=\"patterns\">Patterns and Their Interpretation</a></h3>\n *\n * <code>MessageFormat</code> uses patterns of the following form:\n * <blockquote><pre>\n * message = messageText (argument messageText)*\n * argument = noneArg | simpleArg | complexArg\n * complexArg = choiceArg | pluralArg | selectArg | selectordinalArg\n *\n * noneArg = '{' argNameOrNumber '}'\n * simpleArg = '{' argNameOrNumber ',' argType [',' argStyle] '}'\n * choiceArg = '{' argNameOrNumber ',' \"choice\" ',' choiceStyle '}'\n * pluralArg = '{' argNameOrNumber ',' \"plural\" ',' pluralStyle '}'\n * selectArg = '{' argNameOrNumber ',' \"select\" ',' selectStyle '}'\n * selectordinalArg = '{' argNameOrNumber ',' \"selectordinal\" ',' pluralStyle '}'\n *\n * choiceStyle: see {@link ChoiceFormat}\n * pluralStyle: see {@link PluralFormat}\n * selectStyle: see {@link SelectFormat}\n *\n * argNameOrNumber = argName | argNumber\n * argName = [^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+\n * argNumber = '0' | ('1'..'9' ('0'..'9')*)\n *\n * argType = \"number\" | \"date\" | \"time\" | \"spellout\" | \"ordinal\" | \"duration\"\n * argStyle = \"short\" | \"medium\" | \"long\" | \"full\" | \"integer\" | \"currency\" | \"percent\" | argStyleText\n * </pre></blockquote>\n *\n * <ul>\n *   <li>messageText can contain quoted literal strings including syntax characters.\n *       A quoted literal string begins with an ASCII apostrophe and a syntax character\n *       (usually a {curly brace}) and continues until the next single apostrophe.\n *       A double ASCII apostrophe inside or outside of a quoted string represents\n *       one literal apostrophe.\n *   <li>Quotable syntax characters are the {curly braces} in all messageText parts,\n *       plus the '#' sign in a messageText immediately inside a pluralStyle,\n *       and the '|' symbol in a messageText immediately inside a choiceStyle.\n *   <li>See also {@link MessagePattern.ApostropheMode}\n *   <li>In argStyleText, every single ASCII apostrophe begins and ends quoted literal text,\n *       and unquoted {curly braces} must occur in matched pairs.\n * </ul>\n *\n * <p>Recommendation: Use the real apostrophe (single quote) character \\\\u2019 for\n * human-readable text, and use the ASCII apostrophe (\\\\u0027 ' )\n * only in program syntax, like quoting in MessageFormat.\n * See the annotations for U+0027 Apostrophe in The Unicode Standard.\n *\n * <p>The <code>choice</code> argument type is deprecated.\n * Use <code>plural</code> arguments for proper plural selection,\n * and <code>select</code> arguments for simple selection among a fixed set of choices.\n *\n * <p>The <code>argType</code> and <code>argStyle</code> values are used to create\n * a <code>Format</code> instance for the format element. The following\n * table shows how the values map to Format instances. Combinations not\n * shown in the table are illegal. Any <code>argStyleText</code> must\n * be a valid pattern string for the Format subclass used.\n *\n * <table border=1>\n *    <tr>\n *       <th>argType\n *       <th>argStyle\n *       <th>resulting Format object\n *    <tr>\n *       <td colspan=2><i>(none)</i>\n *       <td><code>null</code>\n *    <tr>\n *       <td rowspan=5><code>number</code>\n *       <td><i>(none)</i>\n *       <td><code>NumberFormat.getInstance(getLocale())</code>\n *    <tr>\n *       <td><code>integer</code>\n *       <td><code>NumberFormat.getIntegerInstance(getLocale())</code>\n *    <tr>\n *       <td><code>currency</code>\n *       <td><code>NumberFormat.getCurrencyInstance(getLocale())</code>\n *    <tr>\n *       <td><code>percent</code>\n *       <td><code>NumberFormat.getPercentInstance(getLocale())</code>\n *    <tr>\n *       <td><i>argStyleText</i>\n *       <td><code>new DecimalFormat(argStyleText, new DecimalFormatSymbols(getLocale()))</code>\n *    <tr>\n *       <td rowspan=6><code>date</code>\n *       <td><i>(none)</i>\n *       <td><code>DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())</code>\n *    <tr>\n *       <td><code>short</code>\n *       <td><code>DateFormat.getDateInstance(DateFormat.SHORT, getLocale())</code>\n *    <tr>\n *       <td><code>medium</code>\n *       <td><code>DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())</code>\n *    <tr>\n *       <td><code>long</code>\n *       <td><code>DateFormat.getDateInstance(DateFormat.LONG, getLocale())</code>\n *    <tr>\n *       <td><code>full</code>\n *       <td><code>DateFormat.getDateInstance(DateFormat.FULL, getLocale())</code>\n *    <tr>\n *       <td><i>argStyleText</i>\n *       <td><code>new SimpleDateFormat(argStyleText, getLocale())</code>\n *    <tr>\n *       <td rowspan=6><code>time</code>\n *       <td><i>(none)</i>\n *       <td><code>DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())</code>\n *    <tr>\n *       <td><code>short</code>\n *       <td><code>DateFormat.getTimeInstance(DateFormat.SHORT, getLocale())</code>\n *    <tr>\n *       <td><code>medium</code>\n *       <td><code>DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())</code>\n *    <tr>\n *       <td><code>long</code>\n *       <td><code>DateFormat.getTimeInstance(DateFormat.LONG, getLocale())</code>\n *    <tr>\n *       <td><code>full</code>\n *       <td><code>DateFormat.getTimeInstance(DateFormat.FULL, getLocale())</code>\n *    <tr>\n *       <td><i>argStyleText</i>\n *       <td><code>new SimpleDateFormat(argStyleText, getLocale())</code>\n *    <tr>\n *       <td><code>spellout</code>\n *       <td><i>argStyleText (optional)</i>\n *       <td><code>new RuleBasedNumberFormat(getLocale(), RuleBasedNumberFormat.SPELLOUT)\n *           <br>&nbsp;&nbsp;&nbsp;&nbsp;.setDefaultRuleset(argStyleText);</code>\n *    <tr>\n *       <td><code>ordinal</code>\n *       <td><i>argStyleText (optional)</i>\n *       <td><code>new RuleBasedNumberFormat(getLocale(), RuleBasedNumberFormat.ORDINAL)\n *           <br>&nbsp;&nbsp;&nbsp;&nbsp;.setDefaultRuleset(argStyleText);</code>\n *    <tr>\n *       <td><code>duration</code>\n *       <td><i>argStyleText (optional)</i>\n *       <td><code>new RuleBasedNumberFormat(getLocale(), RuleBasedNumberFormat.DURATION)\n *           <br>&nbsp;&nbsp;&nbsp;&nbsp;.setDefaultRuleset(argStyleText);</code>\n * </table>\n *\n * <h4><a name=\"diffsjdk\">Differences from java.text.MessageFormat</a></h4>\n *\n * <p>The ICU MessageFormat supports both named and numbered arguments,\n * while the JDK MessageFormat only supports numbered arguments.\n * Named arguments make patterns more readable.\n *\n * <p>ICU implements a more user-friendly apostrophe quoting syntax.\n * In message text, an apostrophe only begins quoting literal text\n * if it immediately precedes a syntax character (mostly {curly braces}).<br>\n * In the JDK MessageFormat, an apostrophe always begins quoting,\n * which requires common text like \"don't\" and \"aujourd'hui\"\n * to be written with doubled apostrophes like \"don''t\" and \"aujourd''hui\".\n * For more details see {@link MessagePattern.ApostropheMode}.\n *\n * <p>ICU does not create a ChoiceFormat object for a choiceArg, pluralArg or selectArg\n * but rather handles such arguments itself.\n * The JDK MessageFormat does create and use a ChoiceFormat object\n * (<code>new ChoiceFormat(argStyleText)</code>).\n * The JDK does not support plural and select arguments at all.\n *\n * <h4>Usage Information</h4>\n *\n * <p>Here are some examples of usage:\n * <blockquote>\n * <pre>\n * Object[] arguments = {\n *     7,\n *     new Date(System.currentTimeMillis()),\n *     \"a disturbance in the Force\"\n * };\n *\n * String result = MessageFormat.format(\n *     \"At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.\",\n *     arguments);\n *\n * <em>output</em>: At 12:30 PM on Jul 3, 2053, there was a disturbance\n *           in the Force on planet 7.\n *\n * </pre>\n * </blockquote>\n * Typically, the message format will come from resources, and the\n * arguments will be dynamically set at runtime.\n *\n * <p>Example 2:\n * <blockquote>\n * <pre>\n * Object[] testArgs = { 3, \"MyDisk\" };\n *\n * MessageFormat form = new MessageFormat(\n *     \"The disk \\\"{1}\\\" contains {0} file(s).\");\n *\n * System.out.println(form.format(testArgs));\n *\n * // output, with different testArgs\n * <em>output</em>: The disk \"MyDisk\" contains 0 file(s).\n * <em>output</em>: The disk \"MyDisk\" contains 1 file(s).\n * <em>output</em>: The disk \"MyDisk\" contains 1,273 file(s).\n * </pre>\n * </blockquote>\n *\n * <p>For messages that include plural forms, you can use a plural argument:\n * <pre>\n * MessageFormat msgFmt = new MessageFormat(\n *     \"{num_files, plural, \" +\n *     \"=0{There are no files on disk \\\"{disk_name}\\\".}\" +\n *     \"=1{There is one file on disk \\\"{disk_name}\\\".}\" +\n *     \"other{There are # files on disk \\\"{disk_name}\\\".}}\",\n *     ULocale.ENGLISH);\n * Map args = new HashMap();\n * args.put(\"num_files\", 0);\n * args.put(\"disk_name\", \"MyDisk\");\n * System.out.println(msgFmt.format(args));\n * args.put(\"num_files\", 3);\n * System.out.println(msgFmt.format(args));\n *\n * <em>output</em>:\n * There are no files on disk \"MyDisk\".\n * There are 3 files on \"MyDisk\".\n * </pre>\n * See {@link PluralFormat} and {@link PluralRules} for details.\n *\n * <h4><a name=\"synchronization\">Synchronization</a></h4>\n *\n * <p>MessageFormats are not synchronized.\n * It is recommended to create separate format instances for each thread.\n * If multiple threads access a format concurrently, it must be synchronized\n * externally.\n *\n * @see          java.util.Locale\n * @see          Format\n * @see          NumberFormat\n * @see          DecimalFormat\n * @see          ChoiceFormat\n * @see          PluralFormat\n * @see          SelectFormat\n * @author       Mark Davis\n * @author       Markus Scherer\n ",
  "links" : [ "android.icu.text.SelectFormat", "#usesNamedArguments()", "android.icu.text.PluralRules", "java.text.ChoiceFormat", "MessagePattern.ApostropheMode", "android.icu.text.PluralFormat", "java.text.MessageFormat" ],
  "variables" : [ {
    "name" : "serialVersionUID",
    "type" : "long",
    "comment" : " Incremented by 1 for ICU 4.8's new format.",
    "links" : [ ]
  }, {
    "name" : "ulocale",
    "type" : "ULocale",
    "comment" : "\n     * The locale to use for formatting numbers and dates.\n     ",
    "links" : [ ]
  }, {
    "name" : "msgPattern",
    "type" : "MessagePattern",
    "comment" : "\n     * The MessagePattern which contains the parsed structure of the pattern string.\n     ",
    "links" : [ ]
  }, {
    "name" : "cachedFormatters",
    "type" : "Map<Integer, Format>",
    "comment" : "\n     * Cached formatters so we can just use them whenever needed instead of creating\n     * them from scratch every time.\n     ",
    "links" : [ ]
  }, {
    "name" : "customFormatArgStarts",
    "type" : "Set<Integer>",
    "comment" : "\n     * Set of ARG_START part indexes where custom, user-provided Format objects\n     * have been set via setFormat() or similar API.\n     ",
    "links" : [ ]
  }, {
    "name" : "stockDateFormatter",
    "type" : "DateFormat",
    "comment" : "\n     * Stock formatters. Those are used when a format is not explicitly mentioned in\n     * the message. The format is inferred from the argument.\n     ",
    "links" : [ ]
  }, {
    "name" : "stockNumberFormatter",
    "type" : "NumberFormat",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "pluralProvider",
    "type" : "PluralSelectorProvider",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ordinalProvider",
    "type" : "PluralSelectorProvider",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "typeList",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_NUMBER",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_DATE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_TIME",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_SPELLOUT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_ORDINAL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TYPE_DURATION",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "modifierList",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MODIFIER_EMPTY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MODIFIER_CURRENCY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MODIFIER_PERCENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MODIFIER_INTEGER",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "dateModifierList",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DATE_MODIFIER_EMPTY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DATE_MODIFIER_SHORT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DATE_MODIFIER_MEDIUM",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DATE_MODIFIER_LONG",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DATE_MODIFIER_FULL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "rootLocale",
    "type" : "Locale",
    "comment" : " Locale.ROOT only @since 1.6",
    "links" : [ ]
  }, {
    "name" : "SINGLE_QUOTE",
    "type" : "char",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CURLY_BRACE_LEFT",
    "type" : "char",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CURLY_BRACE_RIGHT",
    "type" : "char",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATE_INITIAL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATE_SINGLE_QUOTE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATE_IN_QUOTE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATE_MSG_ELEMENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void setLocale(Locale locale)",
    "returnType" : "void",
    "comment" : "\n     * Sets the locale to be used for creating argument Format objects.\n     * This affects subsequent calls to the {@link #applyPattern applyPattern}\n     * method as well as to the <code>format</code> and\n     * {@link #formatToCharacterIterator formatToCharacterIterator} methods.\n     *\n     * @param locale the locale to be used when creating or comparing subformats\n     ",
    "links" : [ "#applyPattern", "#formatToCharacterIterator" ]
  }, {
    "name" : "public void setLocale(ULocale locale)",
    "returnType" : "void",
    "comment" : "\n     * Sets the locale to be used for creating argument Format objects.\n     * This affects subsequent calls to the {@link #applyPattern applyPattern}\n     * method as well as to the <code>format</code> and\n     * {@link #formatToCharacterIterator formatToCharacterIterator} methods.\n     *\n     * @param locale the locale to be used when creating or comparing subformats\n     ",
    "links" : [ "#applyPattern", "#formatToCharacterIterator" ]
  }, {
    "name" : "public Locale getLocale()",
    "returnType" : "Locale",
    "comment" : "\n     * Returns the locale that's used when creating or comparing subformats.\n     *\n     * @return the locale used when creating or comparing subformats\n     ",
    "links" : [ ]
  }, {
    "name" : "public ULocale getULocale()",
    "returnType" : "ULocale",
    "comment" : "\n     * <strong>[icu]</strong> Returns the locale that's used when creating argument Format objects.\n     *\n     * @return the locale used when creating or comparing subformats\n     ",
    "links" : [ ]
  }, {
    "name" : "public void applyPattern(String pttrn)",
    "returnType" : "void",
    "comment" : "\n     * Sets the pattern used by this message format.\n     * Parses the pattern and caches Format objects for simple argument types.\n     * Patterns and their interpretation are specified in the\n     * <a href=\"#patterns\">class description</a>.\n     *\n     * @param pttrn the pattern for this message format\n     * @throws IllegalArgumentException if the pattern is invalid\n     ",
    "links" : [ ]
  }, {
    "name" : "public void applyPattern(String pattern, MessagePattern.ApostropheMode aposMode)",
    "returnType" : "void",
    "comment" : "\n     * <strong>[icu]</strong> Sets the ApostropheMode and the pattern used by this message format.\n     * Parses the pattern and caches Format objects for simple argument types.\n     * Patterns and their interpretation are specified in the\n     * <a href=\"#patterns\">class description</a>.\n     * <p>\n     * This method is best used only once on a given object to avoid confusion about the mode,\n     * and after constructing the object with an empty pattern string to minimize overhead.\n     *\n     * @param pattern the pattern for this message format\n     * @param aposMode the new ApostropheMode\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see MessagePattern.ApostropheMode\n     ",
    "links" : [ ]
  }, {
    "name" : "public MessagePattern.ApostropheMode getApostropheMode()",
    "returnType" : "MessagePattern.ApostropheMode",
    "comment" : "\n     * <strong>[icu]</strong>\n     * @return this instance's ApostropheMode.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toPattern()",
    "returnType" : "String",
    "comment" : "\n     * Returns the applied pattern string.\n     * @return the pattern string\n     * @throws IllegalStateException after custom Format objects have been set\n     *         via setFormat() or similar APIs\n     ",
    "links" : [ ]
  }, {
    "name" : "private int nextTopLevelArgStart(int partIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns the part index of the next ARG_START after partIndex, or -1 if there is none more.\n     * @param partIndex Part index of the previous ARG_START (initially 0).\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean argNameMatches(int partIndex, String argName, int argNumber)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private String getArgName(int partIndex)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setFormatsByArgumentIndex(Format[] newFormats)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Format objects to use for the values passed into\n     * <code>format</code> methods or returned from <code>parse</code>\n     * methods. The indices of elements in <code>newFormats</code>\n     * correspond to the argument indices used in the previously set\n     * pattern string.\n     * The order of formats in <code>newFormats</code> thus corresponds to\n     * the order of elements in the <code>arguments</code> array passed\n     * to the <code>format</code> methods or the result array returned\n     * by the <code>parse</code> methods.\n     * <p>\n     * If an argument index is used for more than one format element\n     * in the pattern string, then the corresponding new format is used\n     * for all such format elements. If an argument index is not used\n     * for any format element in the pattern string, then the\n     * corresponding new format is ignored. If fewer formats are provided\n     * than needed, then only the formats for argument indices less\n     * than <code>newFormats.length</code> are replaced.\n     *\n     * This method is only supported if the format does not use\n     * named arguments, otherwise an IllegalArgumentException is thrown.\n     *\n     * @param newFormats the new formats to use\n     * @throws NullPointerException if <code>newFormats</code> is null\n     * @throws IllegalArgumentException if this formatter uses named arguments\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFormatsByArgumentName(Map<String, Format> newFormats)",
    "returnType" : "void",
    "comment" : "\n     * <strong>[icu]</strong> Sets the Format objects to use for the values passed into\n     * <code>format</code> methods or returned from <code>parse</code>\n     * methods. The keys in <code>newFormats</code> are the argument\n     * names in the previously set pattern string, and the values\n     * are the formats.\n     * <p>\n     * Only argument names from the pattern string are considered.\n     * Extra keys in <code>newFormats</code> that do not correspond\n     * to an argument name are ignored.  Similarly, if there is no\n     * format in newFormats for an argument name, the formatter\n     * for that argument remains unchanged.\n     * <p>\n     * This may be called on formats that do not use named arguments.\n     * In this case the map will be queried for key Strings that\n     * represent argument indices, e.g. \"0\", \"1\", \"2\" etc.\n     *\n     * @param newFormats a map from String to Format providing new\n     *        formats for named arguments.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFormats(Format[] newFormats)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Format objects to use for the format elements in the\n     * previously set pattern string.\n     * The order of formats in <code>newFormats</code> corresponds to\n     * the order of format elements in the pattern string.\n     * <p>\n     * If more formats are provided than needed by the pattern string,\n     * the remaining ones are ignored. If fewer formats are provided\n     * than needed, then only the first <code>newFormats.length</code>\n     * formats are replaced.\n     * <p>\n     * Since the order of format elements in a pattern string often\n     * changes during localization, it is generally better to use the\n     * {@link #setFormatsByArgumentIndex setFormatsByArgumentIndex}\n     * method, which assumes an order of formats corresponding to the\n     * order of elements in the <code>arguments</code> array passed to\n     * the <code>format</code> methods or the result array returned by\n     * the <code>parse</code> methods.\n     *\n     * @param newFormats the new formats to use\n     * @exception NullPointerException if <code>newFormats</code> is null\n     ",
    "links" : [ "#setFormatsByArgumentIndex" ]
  }, {
    "name" : "public void setFormatByArgumentIndex(int argumentIndex, Format newFormat)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Format object to use for the format elements within the\n     * previously set pattern string that use the given argument\n     * index.\n     * The argument index is part of the format element definition and\n     * represents an index into the <code>arguments</code> array passed\n     * to the <code>format</code> methods or the result array returned\n     * by the <code>parse</code> methods.\n     * <p>\n     * If the argument index is used for more than one format element\n     * in the pattern string, then the new format is used for all such\n     * format elements. If the argument index is not used for any format\n     * element in the pattern string, then the new format is ignored.\n     *\n     * This method is only supported when exclusively numbers are used for\n     * argument names. Otherwise an IllegalArgumentException is thrown.\n     *\n     * @param argumentIndex the argument index for which to use the new format\n     * @param newFormat the new format to use\n     * @throws IllegalArgumentException if this format uses named arguments\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFormatByArgumentName(String argumentName, Format newFormat)",
    "returnType" : "void",
    "comment" : "\n     * <strong>[icu]</strong> Sets the Format object to use for the format elements within the\n     * previously set pattern string that use the given argument\n     * name.\n     * <p>\n     * If the argument name is used for more than one format element\n     * in the pattern string, then the new format is used for all such\n     * format elements. If the argument name is not used for any format\n     * element in the pattern string, then the new format is ignored.\n     * <p>\n     * This API may be used on formats that do not use named arguments.\n     * In this case <code>argumentName</code> should be a String that names\n     * an argument index, e.g. \"0\", \"1\", \"2\"... etc.  If it does not name\n     * a valid index, the format will be ignored.  No error is thrown.\n     *\n     * @param argumentName the name of the argument to change\n     * @param newFormat the new format to use\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFormat(int formatElementIndex, Format newFormat)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Format object to use for the format element with the given\n     * format element index within the previously set pattern string.\n     * The format element index is the zero-based number of the format\n     * element counting from the start of the pattern string.\n     * <p>\n     * Since the order of format elements in a pattern string often\n     * changes during localization, it is generally better to use the\n     * {@link #setFormatByArgumentIndex setFormatByArgumentIndex}\n     * method, which accesses format elements based on the argument\n     * index they specify.\n     *\n     * @param formatElementIndex the index of a format element within the pattern\n     * @param newFormat the format to use for the specified format element\n     * @exception ArrayIndexOutOfBoundsException if formatElementIndex is equal to or\n     *            larger than the number of format elements in the pattern string\n     ",
    "links" : [ "#setFormatByArgumentIndex" ]
  }, {
    "name" : "public Format[] getFormatsByArgumentIndex()",
    "returnType" : "Format[]",
    "comment" : "\n     * Returns the Format objects used for the values passed into\n     * <code>format</code> methods or returned from <code>parse</code>\n     * methods. The indices of elements in the returned array\n     * correspond to the argument indices used in the previously set\n     * pattern string.\n     * The order of formats in the returned array thus corresponds to\n     * the order of elements in the <code>arguments</code> array passed\n     * to the <code>format</code> methods or the result array returned\n     * by the <code>parse</code> methods.\n     * <p>\n     * If an argument index is used for more than one format element\n     * in the pattern string, then the format used for the last such\n     * format element is returned in the array. If an argument index\n     * is not used for any format element in the pattern string, then\n     * null is returned in the array.\n     *\n     * This method is only supported when exclusively numbers are used for\n     * argument names. Otherwise an IllegalArgumentException is thrown.\n     *\n     * @return the formats used for the arguments within the pattern\n     * @throws IllegalArgumentException if this format uses named arguments\n     ",
    "links" : [ ]
  }, {
    "name" : "public Format[] getFormats()",
    "returnType" : "Format[]",
    "comment" : "\n     * Returns the Format objects used for the format elements in the\n     * previously set pattern string.\n     * The order of formats in the returned array corresponds to\n     * the order of format elements in the pattern string.\n     * <p>\n     * Since the order of format elements in a pattern string often\n     * changes during localization, it's generally better to use the\n     * {@link #getFormatsByArgumentIndex()}\n     * method, which assumes an order of formats corresponding to the\n     * order of elements in the <code>arguments</code> array passed to\n     * the <code>format</code> methods or the result array returned by\n     * the <code>parse</code> methods.\n     *\n     * This method is only supported when exclusively numbers are used for\n     * argument names. Otherwise an IllegalArgumentException is thrown.\n     *\n     * @return the formats used for the format elements in the pattern\n     * @throws IllegalArgumentException if this format uses named arguments\n     ",
    "links" : [ "#getFormatsByArgumentIndex()" ]
  }, {
    "name" : "public Set<String> getArgumentNames()",
    "returnType" : "Set<String>",
    "comment" : "\n     * <strong>[icu]</strong> Returns the top-level argument names. For more details, see\n     * {@link #setFormatByArgumentName(String, Format)}.\n     * @return a Set of argument names\n     ",
    "links" : [ "#setFormatByArgumentName(String" ]
  }, {
    "name" : "public Format getFormatByArgumentName(String argumentName)",
    "returnType" : "Format",
    "comment" : "\n     * <strong>[icu]</strong> Returns the first top-level format associated with the given argument name.\n     * For more details, see {@link #setFormatByArgumentName(String, Format)}.\n     * @param argumentName The name of the desired argument.\n     * @return the Format associated with the name, or null if there isn't one.\n     ",
    "links" : [ "#setFormatByArgumentName(String" ]
  }, {
    "name" : "public final StringBuffer format(Object[] arguments, StringBuffer result, FieldPosition pos)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Formats an array of objects and appends the <code>MessageFormat</code>'s\n     * pattern, with arguments replaced by the formatted objects, to the\n     * provided <code>StringBuffer</code>.\n     * <p>\n     * The text substituted for the individual format elements is derived from\n     * the current subformat of the format element and the\n     * <code>arguments</code> element at the format element's argument index\n     * as indicated by the first matching line of the following table. An\n     * argument is <i>unavailable</i> if <code>arguments</code> is\n     * <code>null</code> or has fewer than argumentIndex+1 elements.  When\n     * an argument is unavailable no substitution is performed.\n     *\n     * <table border=1>\n     *    <tr>\n     *       <th>argType or Format\n     *       <th>value object\n     *       <th>Formatted Text\n     *    <tr>\n     *       <td><i>any</i>\n     *       <td><i>unavailable</i>\n     *       <td><code>\"{\" + argNameOrNumber + \"}\"</code>\n     *    <tr>\n     *       <td><i>any</i>\n     *       <td><code>null</code>\n     *       <td><code>\"null\"</code>\n     *    <tr>\n     *       <td>custom Format <code>!= null</code>\n     *       <td><i>any</i>\n     *       <td><code>customFormat.format(argument)</code>\n     *    <tr>\n     *       <td>noneArg, or custom Format <code>== null</code>\n     *       <td><code>instanceof Number</code>\n     *       <td><code>NumberFormat.getInstance(getLocale()).format(argument)</code>\n     *    <tr>\n     *       <td>noneArg, or custom Format <code>== null</code>\n     *       <td><code>instanceof Date</code>\n     *       <td><code>DateFormat.getDateTimeInstance(DateFormat.SHORT,\n     *           DateFormat.SHORT, getLocale()).format(argument)</code>\n     *    <tr>\n     *       <td>noneArg, or custom Format <code>== null</code>\n     *       <td><code>instanceof String</code>\n     *       <td><code>argument</code>\n     *    <tr>\n     *       <td>noneArg, or custom Format <code>== null</code>\n     *       <td><i>any</i>\n     *       <td><code>argument.toString()</code>\n     *    <tr>\n     *       <td>complexArg\n     *       <td><i>any</i>\n     *       <td>result of recursive formatting of a selected sub-message\n     * </table>\n     * <p>\n     * If <code>pos</code> is non-null, and refers to\n     * <code>Field.ARGUMENT</code>, the location of the first formatted\n     * string will be returned.\n     *\n     * This method is only supported when the format does not use named\n     * arguments, otherwise an IllegalArgumentException is thrown.\n     *\n     * @param arguments an array of objects to be formatted and substituted.\n     * @param result where text is appended.\n     * @param pos On input: an alignment field, if desired.\n     *            On output: the offsets of the alignment field.\n     * @throws IllegalArgumentException if a value in the\n     *         <code>arguments</code> array is not of the type\n     *         expected by the corresponding argument or custom Format object.\n     * @throws IllegalArgumentException if this format uses named arguments\n     ",
    "links" : [ ]
  }, {
    "name" : "public final StringBuffer format(Map<String, Object> arguments, StringBuffer result, FieldPosition pos)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Formats a map of objects and appends the <code>MessageFormat</code>'s\n     * pattern, with arguments replaced by the formatted objects, to the\n     * provided <code>StringBuffer</code>.\n     * <p>\n     * The text substituted for the individual format elements is derived from\n     * the current subformat of the format element and the\n     * <code>arguments</code> value corresponding to the format element's\n     * argument name.\n     * <p>\n     * A numbered pattern argument is matched with a map key that contains that number\n     * as an ASCII-decimal-digit string (without leading zero).\n     * <p>\n     * An argument is <i>unavailable</i> if <code>arguments</code> is\n     * <code>null</code> or does not have a value corresponding to an argument\n     * name in the pattern.  When an argument is unavailable no substitution\n     * is performed.\n     *\n     * @param arguments a map of objects to be formatted and substituted.\n     * @param result where text is appended.\n     * @param pos On input: an alignment field, if desired.\n     *            On output: the offsets of the alignment field.\n     * @throws IllegalArgumentException if a value in the\n     *         <code>arguments</code> array is not of the type\n     *         expected by the corresponding argument or custom Format object.\n     * @return the passed-in StringBuffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String format(String pattern, Object... arguments)",
    "returnType" : "String",
    "comment" : "\n     * Creates a MessageFormat with the given pattern and uses it\n     * to format the given arguments. This is equivalent to\n     * <blockquote>\n     *     <code>(new {@link #MessageFormat(String) MessageFormat}(pattern)).{@link\n     *     #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition)\n     *     format}(arguments, new StringBuffer(), null).toString()</code>\n     * </blockquote>\n     *\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @throws IllegalArgumentException if a value in the\n     *         <code>arguments</code> array is not of the type\n     *         expected by the corresponding argument or custom Format object.\n     * @throws IllegalArgumentException if this format uses named arguments\n     ",
    "links" : [ "#MessageFormat(String)", "#format(java.lang.Object" ]
  }, {
    "name" : "public static String format(String pattern, Map<String, Object> arguments)",
    "returnType" : "String",
    "comment" : "\n     * Creates a MessageFormat with the given pattern and uses it to\n     * format the given arguments.  The pattern must identifyarguments\n     * by name instead of by number.\n     * <p>\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @throws IllegalArgumentException if a value in the\n     *         <code>arguments</code> array is not of the type\n     *         expected by the corresponding argument or custom Format object.\n     * @see #format(Map, StringBuffer, FieldPosition)\n     * @see #format(String, Object[])\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean usesNamedArguments()",
    "returnType" : "boolean",
    "comment" : "\n     * <strong>[icu]</strong> Returns true if this MessageFormat uses named arguments,\n     * and false otherwise.  See class description.\n     *\n     * @return true if named arguments are used.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final StringBuffer format(Object arguments, StringBuffer result, FieldPosition pos)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Formats a map or array of objects and appends the <code>MessageFormat</code>'s\n     * pattern, with format elements replaced by the formatted objects, to the\n     * provided <code>StringBuffer</code>.\n     * This is equivalent to either of\n     * <blockquote>\n     *     <code>{@link #format(java.lang.Object[], java.lang.StringBuffer,\n     *     java.text.FieldPosition) format}((Object[]) arguments, result, pos)</code>\n     *     <code>{@link #format(java.util.Map, java.lang.StringBuffer,\n     *     java.text.FieldPosition) format}((Map) arguments, result, pos)</code>\n     * </blockquote>\n     * A map must be provided if this format uses named arguments, otherwise\n     * an IllegalArgumentException will be thrown.\n     * @param arguments a map or array of objects to be formatted\n     * @param result where text is appended\n     * @param pos On input: an alignment field, if desired\n     *            On output: the offsets of the alignment field\n     * @throws IllegalArgumentException if an argument in\n     *         <code>arguments</code> is not of the type\n     *         expected by the format element(s) that use it\n     * @throws IllegalArgumentException if <code>arguments</code> is\n     *         an array of Object and this format uses named arguments\n     ",
    "links" : [ "#format(java.lang.Object", "#format(java.util.Map" ]
  }, {
    "name" : "public AttributedCharacterIterator formatToCharacterIterator(Object arguments)",
    "returnType" : "AttributedCharacterIterator",
    "comment" : "\n     * Formats an array of objects and inserts them into the\n     * <code>MessageFormat</code>'s pattern, producing an\n     * <code>AttributedCharacterIterator</code>.\n     * You can use the returned <code>AttributedCharacterIterator</code>\n     * to build the resulting String, as well as to determine information\n     * about the resulting String.\n     * <p>\n     * The text of the returned <code>AttributedCharacterIterator</code> is\n     * the same that would be returned by\n     * <blockquote>\n     *     <code>{@link #format(java.lang.Object[], java.lang.StringBuffer,\n     *     java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()</code>\n     * </blockquote>\n     * <p>\n     * In addition, the <code>AttributedCharacterIterator</code> contains at\n     * least attributes indicating where text was generated from an\n     * argument in the <code>arguments</code> array. The keys of these attributes are of\n     * type <code>MessageFormat.Field</code>, their values are\n     * <code>Integer</code> objects indicating the index in the <code>arguments</code>\n     * array of the argument from which the text was generated.\n     * <p>\n     * The attributes/value from the underlying <code>Format</code>\n     * instances that <code>MessageFormat</code> uses will also be\n     * placed in the resulting <code>AttributedCharacterIterator</code>.\n     * This allows you to not only find where an argument is placed in the\n     * resulting String, but also which fields it contains in turn.\n     *\n     * @param arguments an array of objects to be formatted and substituted.\n     * @return AttributedCharacterIterator describing the formatted value.\n     * @exception NullPointerException if <code>arguments</code> is null.\n     * @throws IllegalArgumentException if a value in the\n     *         <code>arguments</code> array is not of the type\n     *         expected by the corresponding argument or custom Format object.\n     ",
    "links" : [ "#format(java.lang.Object" ]
  }, {
    "name" : "public Object[] parse(String source, ParsePosition pos)",
    "returnType" : "Object[]",
    "comment" : "\n     * Parses the string.\n     *\n     * <p>Caveats: The parse may fail in a number of circumstances.\n     * For example:\n     * <ul>\n     * <li>If one of the arguments does not occur in the pattern.\n     * <li>If the format of an argument loses information, such as\n     *     with a choice format where a large number formats to \"many\".\n     * <li>Does not yet handle recursion (where\n     *     the substituted strings contain {n} references.)\n     * <li>Will not always find a match (or the correct match)\n     *     if some part of the parse is ambiguous.\n     *     For example, if the pattern \"{1},{2}\" is used with the\n     *     string arguments {\"a,b\", \"c\"}, it will format as \"a,b,c\".\n     *     When the result is parsed, it will return {\"a\", \"b,c\"}.\n     * <li>If a single argument is parsed more than once in the string,\n     *     then the later parse wins.\n     * </ul>\n     * When the parse fails, use ParsePosition.getErrorIndex() to find out\n     * where in the string did the parsing failed. The returned error\n     * index is the starting offset of the sub-patterns that the string\n     * is comparing with. For example, if the parsing string \"AAA {0} BBB\"\n     * is comparing against the pattern \"AAD {0} BBB\", the error index is\n     * 0. When an error occurs, the call to this method will return null.\n     * If the source is null, return an empty array.\n     *\n     * @throws IllegalArgumentException if this format uses named arguments\n     ",
    "links" : [ ]
  }, {
    "name" : "public Map<String, Object> parseToMap(String source, ParsePosition pos)",
    "returnType" : "Map<String, Object>",
    "comment" : "\n     * <strong>[icu]</strong> Parses the string, returning the results in a Map.\n     * This is similar to the version that returns an array\n     * of Object.  This supports both named and numbered\n     * arguments-- if numbered, the keys in the map are the\n     * corresponding ASCII-decimal-digit strings (e.g. \"0\", \"1\", \"2\"...).\n     *\n     * @param source the text to parse\n     * @param pos the position at which to start parsing.  on return,\n     *        contains the result of the parse.\n     * @return a Map containing key/value pairs for each parsed argument.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Object[] parse(String source) throws ParseException",
    "returnType" : "Object[]",
    "comment" : "\n     * Parses text from the beginning of the given string to produce an object\n     * array.\n     * The method may not use the entire text of the given string.\n     * <p>\n     * See the {@link #parse(String, ParsePosition)} method for more information\n     * on message parsing.\n     *\n     * @param source A <code>String</code> whose beginning should be parsed.\n     * @return An <code>Object</code> array parsed from the string.\n     * @exception ParseException if the beginning of the specified string cannot be parsed.\n     * @exception IllegalArgumentException if this format uses named arguments\n     ",
    "links" : [ "#parse(String" ]
  }, {
    "name" : "private void parse(int msgStart, String source, ParsePosition pos, Object[] args, Map<String, Object> argsMap)",
    "returnType" : "void",
    "comment" : "\n     * Parses the string, filling either the Map or the Array.\n     * This is a private method that all the public parsing methods call.\n     * This supports both named and numbered\n     * arguments-- if numbered, the keys in the map are the\n     * corresponding ASCII-decimal-digit strings (e.g. \"0\", \"1\", \"2\"...).\n     *\n     * @param msgStart index in the message pattern to start from.\n     * @param source the text to parse\n     * @param pos the position at which to start parsing.  on return,\n     *        contains the result of the parse.\n     * @param args if not null, the parse results will be filled here (The pattern\n     *        has to have numbered arguments in order for this to not be null).\n     * @param argsMap if not null, the parse results will be filled here.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Map<String, Object> parseToMap(String source) throws ParseException",
    "returnType" : "Map<String, Object>",
    "comment" : "\n     * <strong>[icu]</strong> Parses text from the beginning of the given string to produce a map from\n     * argument to values. The method may not use the entire text of the given string.\n     *\n     * <p>See the {@link #parse(String, ParsePosition)} method for more information on\n     * message parsing.\n     *\n     * @param source A <code>String</code> whose beginning should be parsed.\n     * @return A <code>Map</code> parsed from the string.\n     * @throws ParseException if the beginning of the specified string cannot\n     *         be parsed.\n     * @see #parseToMap(String, ParsePosition)\n     ",
    "links" : [ "#parse(String" ]
  }, {
    "name" : "public Object parseObject(String source, ParsePosition pos)",
    "returnType" : "Object",
    "comment" : "\n     * Parses text from a string to produce an object array or Map.\n     * <p>\n     * The method attempts to parse text starting at the index given by\n     * <code>pos</code>.\n     * If parsing succeeds, then the index of <code>pos</code> is updated\n     * to the index after the last character used (parsing does not necessarily\n     * use all characters up to the end of the string), and the parsed\n     * object array is returned. The updated <code>pos</code> can be used to\n     * indicate the starting point for the next call to this method.\n     * If an error occurs, then the index of <code>pos</code> is not\n     * changed, the error index of <code>pos</code> is set to the index of\n     * the character where the error occurred, and null is returned.\n     * <p>\n     * See the {@link #parse(String, ParsePosition)} method for more information\n     * on message parsing.\n     *\n     * @param source A <code>String</code>, part of which should be parsed.\n     * @param pos A <code>ParsePosition</code> object with index and error\n     *            index information as described above.\n     * @return An <code>Object</code> parsed from the string, either an\n     *         array of Object, or a Map, depending on whether named\n     *         arguments are used.  This can be queried using <code>usesNamedArguments</code>.\n     *         In case of error, returns null.\n     * @throws NullPointerException if <code>pos</code> is null.\n     ",
    "links" : [ "#parse(String" ]
  }, {
    "name" : "public Object clone()",
    "returnType" : "Object",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object obj)",
    "returnType" : "boolean",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "private DateFormat getStockDateFormatter()",
    "returnType" : "DateFormat",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private NumberFormat getStockNumberFormatter()",
    "returnType" : "NumberFormat",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void format(int msgStart, PluralSelectorContext pluralNumber, Object[] args, Map<String, Object> argsMap, AppendableWrapper dest, FieldPosition fp)",
    "returnType" : "void",
    "comment" : "\n     * Formats the arguments and writes the result into the\n     * AppendableWrapper, updates the field position.\n     *\n     * <p>Exactly one of args and argsMap must be null, the other non-null.\n     *\n     * @param msgStart      Index to msgPattern part to start formatting from.\n     * @param pluralNumber  null except when formatting a plural argument sub-message\n     *                      where a '#' is replaced by the format string for this number.\n     * @param args          The formattable objects array. Non-null iff numbered values are used.\n     * @param argsMap       The key-value map of formattable objects. Non-null iff named values are used.\n     * @param dest          Output parameter to receive the result.\n     *                      The result (string & attributes) is appended to existing contents.\n     * @param fp            Field position status.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void formatComplexSubMessage(int msgStart, PluralSelectorContext pluralNumber, Object[] args, Map<String, Object> argsMap, AppendableWrapper dest)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private String getLiteralStringUntilNextArgument(int from)",
    "returnType" : "String",
    "comment" : "\n     * Read as much literal string from the pattern string as possible. This stops\n     * as soon as it finds an argument, or it reaches the end of the string.\n     * @param from Index in the pattern string to start from.\n     * @return A substring from the pattern string representing the longest possible\n     *         substring with no arguments.\n     ",
    "links" : [ ]
  }, {
    "name" : "private FieldPosition updateMetaData(AppendableWrapper dest, int prevLength, FieldPosition fp, Object argId)",
    "returnType" : "FieldPosition",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int findChoiceSubMessage(MessagePattern pattern, int partIndex, double number)",
    "returnType" : "int",
    "comment" : "\n     * Finds the ChoiceFormat sub-message for the given number.\n     * @param pattern A MessagePattern.\n     * @param partIndex the index of the first ChoiceFormat argument style part.\n     * @param number a number to be mapped to one of the ChoiceFormat argument's intervals\n     * @return the sub-message start part index.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static double parseChoiceArgument(MessagePattern pattern, int partIndex, String source, ParsePosition pos)",
    "returnType" : "double",
    "comment" : " Ported from C++ ChoiceFormat::parse().",
    "links" : [ ]
  }, {
    "name" : "private static int matchStringUntilLimitPart(MessagePattern pattern, int partIndex, int limitPartIndex, String source, int sourceOffset)",
    "returnType" : "int",
    "comment" : "\n     * Matches the pattern string from the end of the partIndex to\n     * the beginning of the limitPartIndex,\n     * including all syntax except SKIP_SYNTAX,\n     * against the source string starting at sourceOffset.\n     * If they match, returns the length of the source string match.\n     * Otherwise returns -1.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int findOtherSubMessage(int partIndex)",
    "returnType" : "int",
    "comment" : "\n     * Finds the \"other\" sub-message.\n     * @param partIndex the index of the first PluralFormat argument style part.\n     * @return the \"other\" sub-message start part index.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int findFirstPluralNumberArg(int msgStart, String argName)",
    "returnType" : "int",
    "comment" : "\n     * Returns the ARG_START index of the first occurrence of the plural number in a sub-message.\n     * Returns -1 if it is a REPLACE_NUMBER.\n     * Returns 0 if there is neither.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void format(Object arguments, AppendableWrapper result, FieldPosition fp)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void format(Object[] arguments, Map<String, Object> argsMap, AppendableWrapper dest, FieldPosition fp)",
    "returnType" : "void",
    "comment" : "\n     * Internal routine used by format.\n     *\n     * @throws IllegalArgumentException if an argument in the\n     *         <code>arguments</code> map is not of the type\n     *         expected by the format element(s) that use it.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void resetPattern()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " Format dateTimeFormatForPatternOrSkeleton(String style)",
    "returnType" : "Format",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Format createAppropriateFormat(String type, String style)",
    "returnType" : "Format",
    "comment" : " Both arguments cannot be null.",
    "links" : [ ]
  }, {
    "name" : "private static final int findKeyword(String s, String[] list)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void writeObject(java.io.ObjectOutputStream out) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Custom serialization, new in ICU 4.8.\n     * We do not want to use default serialization because we only have a small\n     * amount of persistent state which is better expressed explicitly\n     * rather than via writing field objects.\n     * @param out The output stream.\n     * @serialData Writes the locale as a BCP 47 language tag string,\n     * the MessagePattern.ApostropheMode as an object,\n     * and the pattern string (null if none was applied).\n     * Followed by an int with the number of (int formatIndex, Object formatter) pairs,\n     * and that many such pairs, corresponding to previous setFormat() calls for custom formats.\n     * Followed by an int with the number of (int, Object) pairs,\n     * and that many such pairs, for future (post-ICU 4.8) extension of the serialization format.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException",
    "returnType" : "void",
    "comment" : "\n     * Custom deserialization, new in ICU 4.8. See comments on writeObject().\n     * @throws InvalidObjectException if the objects read from the stream is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void cacheExplicitFormats()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setArgStartFormat(int argStart, Format formatter)",
    "returnType" : "void",
    "comment" : "\n     * Sets a formatter for a MessagePattern ARG_START part index.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setCustomArgStartFormat(int argStart, Format formatter)",
    "returnType" : "void",
    "comment" : "\n     * Sets a custom formatter for a MessagePattern ARG_START part index.\n     * \"Custom\" formatters are provided by the user via setFormat() or similar APIs.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String autoQuoteApostrophe(String pattern)",
    "returnType" : "String",
    "comment" : "\n     * <strong>[icu]</strong> Converts an 'apostrophe-friendly' pattern into a standard\n     * pattern.\n     * <em>This is obsolete for ICU 4.8 and higher MessageFormat pattern strings.</em>\n     * It can still be useful together with {@link java.text.MessageFormat}.\n     *\n     * <p>See the class description for more about apostrophes and quoting,\n     * and differences between ICU and {@link java.text.MessageFormat}.\n     *\n     * <p>{@link java.text.MessageFormat} and ICU 4.6 and earlier MessageFormat\n     * treat all ASCII apostrophes as\n     * quotes, which is problematic in some languages, e.g.\n     * French, where apostrophe is commonly used.  This utility\n     * assumes that only an unpaired apostrophe immediately before\n     * a brace is a true quote.  Other unpaired apostrophes are paired,\n     * and the resulting standard pattern string is returned.\n     *\n     * <p><b>Note</b>: It is not guaranteed that the returned pattern\n     * is indeed a valid pattern.  The only effect is to convert\n     * between patterns having different quoting semantics.\n     *\n     * <p><b>Note</b>: This method only works on top-level messageText,\n     * not messageText nested inside a complexArg.\n     *\n     * @param pattern the 'apostrophe-friendly' pattern to convert\n     * @return the standard equivalent of the original pattern\n     ",
    "links" : [ "java.text.MessageFormat" ]
  } ],
  "methodNames" : [ "public void setLocale(Locale locale)", "public void setLocale(ULocale locale)", "public Locale getLocale()", "public ULocale getULocale()", "public void applyPattern(String pttrn)", "public void applyPattern(String pattern, MessagePattern.ApostropheMode aposMode)", "public MessagePattern.ApostropheMode getApostropheMode()", "public String toPattern()", "private int nextTopLevelArgStart(int partIndex)", "private boolean argNameMatches(int partIndex, String argName, int argNumber)", "private String getArgName(int partIndex)", "public void setFormatsByArgumentIndex(Format[] newFormats)", "public void setFormatsByArgumentName(Map<String, Format> newFormats)", "public void setFormats(Format[] newFormats)", "public void setFormatByArgumentIndex(int argumentIndex, Format newFormat)", "public void setFormatByArgumentName(String argumentName, Format newFormat)", "public void setFormat(int formatElementIndex, Format newFormat)", "public Format[] getFormatsByArgumentIndex()", "public Format[] getFormats()", "public Set<String> getArgumentNames()", "public Format getFormatByArgumentName(String argumentName)", "public final StringBuffer format(Object[] arguments, StringBuffer result, FieldPosition pos)", "public final StringBuffer format(Map<String, Object> arguments, StringBuffer result, FieldPosition pos)", "public static String format(String pattern, Object... arguments)", "public static String format(String pattern, Map<String, Object> arguments)", "public boolean usesNamedArguments()", "public final StringBuffer format(Object arguments, StringBuffer result, FieldPosition pos)", "public AttributedCharacterIterator formatToCharacterIterator(Object arguments)", "public Object[] parse(String source, ParsePosition pos)", "public Map<String, Object> parseToMap(String source, ParsePosition pos)", "public Object[] parse(String source) throws ParseException", "private void parse(int msgStart, String source, ParsePosition pos, Object[] args, Map<String, Object> argsMap)", "public Map<String, Object> parseToMap(String source) throws ParseException", "public Object parseObject(String source, ParsePosition pos)", "public Object clone()", "public boolean equals(Object obj)", "public int hashCode()", "private DateFormat getStockDateFormatter()", "private NumberFormat getStockNumberFormatter()", "private void format(int msgStart, PluralSelectorContext pluralNumber, Object[] args, Map<String, Object> argsMap, AppendableWrapper dest, FieldPosition fp)", "private void formatComplexSubMessage(int msgStart, PluralSelectorContext pluralNumber, Object[] args, Map<String, Object> argsMap, AppendableWrapper dest)", "private String getLiteralStringUntilNextArgument(int from)", "private FieldPosition updateMetaData(AppendableWrapper dest, int prevLength, FieldPosition fp, Object argId)", "private static int findChoiceSubMessage(MessagePattern pattern, int partIndex, double number)", "private static double parseChoiceArgument(MessagePattern pattern, int partIndex, String source, ParsePosition pos)", "private static int matchStringUntilLimitPart(MessagePattern pattern, int partIndex, int limitPartIndex, String source, int sourceOffset)", "private int findOtherSubMessage(int partIndex)", "private int findFirstPluralNumberArg(int msgStart, String argName)", "private void format(Object arguments, AppendableWrapper result, FieldPosition fp)", "private void format(Object[] arguments, Map<String, Object> argsMap, AppendableWrapper dest, FieldPosition fp)", "private void resetPattern()", " Format dateTimeFormatForPatternOrSkeleton(String style)", "private Format createAppropriateFormat(String type, String style)", "private static final int findKeyword(String s, String[] list)", "private void writeObject(java.io.ObjectOutputStream out) throws IOException", "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException", "private void cacheExplicitFormats()", "private void setArgStartFormat(int argStart, Format formatter)", "private void setCustomArgStartFormat(int argStart, Format formatter)", "public static String autoQuoteApostrophe(String pattern)" ],
  "variableNames" : [ "serialVersionUID", "ulocale", "msgPattern", "cachedFormatters", "customFormatArgStarts", "stockDateFormatter", "stockNumberFormatter", "pluralProvider", "ordinalProvider", "typeList", "TYPE_NUMBER", "TYPE_DATE", "TYPE_TIME", "TYPE_SPELLOUT", "TYPE_ORDINAL", "TYPE_DURATION", "modifierList", "MODIFIER_EMPTY", "MODIFIER_CURRENCY", "MODIFIER_PERCENT", "MODIFIER_INTEGER", "dateModifierList", "DATE_MODIFIER_EMPTY", "DATE_MODIFIER_SHORT", "DATE_MODIFIER_MEDIUM", "DATE_MODIFIER_LONG", "DATE_MODIFIER_FULL", "rootLocale", "SINGLE_QUOTE", "CURLY_BRACE_LEFT", "CURLY_BRACE_RIGHT", "STATE_INITIAL", "STATE_SINGLE_QUOTE", "STATE_IN_QUOTE", "STATE_MSG_ELEMENT" ]
}