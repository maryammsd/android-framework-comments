{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/nio/ByteBuffer.java",
  "packageName" : "java.nio",
  "className" : "ByteBuffer",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "ARRAY_BASE_OFFSET",
    "type" : "long",
    "comment" : " Cached array base offset",
    "links" : [ ]
  }, {
    "name" : "hb",
    "type" : "byte[]",
    "comment" : " Non-null only for heap buffers",
    "links" : [ ]
  }, {
    "name" : "offset",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "isReadOnly",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ELEMENT_SIZE_SHIFT",
    "type" : "int",
    "comment" : " Android-added: Added ELEMENT_SIZE_SHIFT for NIOAccess class and @UnsupportedAppUsage.",
    "links" : [ ]
  }, {
    "name" : "bigEndian",
    "type" : "// package-private\nboolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "nativeByteOrder",
    "type" : "// package-private\nboolean",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : " Object base()",
    "returnType" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static ByteBuffer allocateDirect(int capacity)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Allocates a new direct byte buffer.\n     *\n     * <p> The new buffer's position will be zero, its limit will be its\n     * capacity, its mark will be undefined, each of its elements will be\n     * initialized to zero, and its byte order will be\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.  Whether or not it has a\n     * {@link #hasArray backing array} is unspecified.\n     *\n     * @param  capacity\n     *         The new buffer's capacity, in bytes\n     *\n     * @return  The new byte buffer\n     *\n     * @throws  IllegalArgumentException\n     *          If the {@code capacity} is a negative integer\n     ",
    "links" : [ "java.nio.ByteOrder#BIG_ENDIAN", "#hasArray" ]
  }, {
    "name" : "public static ByteBuffer allocate(int capacity)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Allocates a new byte buffer.\n     *\n     * <p> The new buffer's position will be zero, its limit will be its\n     * capacity, its mark will be undefined, each of its elements will be\n     * initialized to zero, and its byte order will be\n\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\n\n\n\n\n     * It will have a {@link #array backing array}, and its\n     * {@link #arrayOffset array offset} will be zero.\n     *\n     * @param  capacity\n     *         The new buffer's capacity, in bytes\n     *\n     * @return  The new byte buffer\n     *\n     * @throws  IllegalArgumentException\n     *          If the {@code capacity} is a negative integer\n     ",
    "links" : [ "#array", "#arrayOffset", "java.nio.ByteOrder#BIG_ENDIAN" ]
  }, {
    "name" : "public static ByteBuffer wrap(byte[] array, int offset, int length)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Wraps a byte array into a buffer.\n     *\n     * <p> The new buffer will be backed by the given byte array;\n     * that is, modifications to the buffer will cause the array to be modified\n     * and vice versa.  The new buffer's capacity will be\n     * {@code array.length}, its position will be {@code offset}, its limit\n     * will be {@code offset + length}, its mark will be undefined, and its\n     * byte order will be\n\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\n\n\n\n\n     * Its {@link #array backing array} will be the given array, and\n     * its {@link #arrayOffset array offset} will be zero.  </p>\n     *\n     * @param  array\n     *         The array that will back the new buffer\n     *\n     * @param  offset\n     *         The offset of the subarray to be used; must be non-negative and\n     *         no larger than {@code array.length}.  The new buffer's position\n     *         will be set to this value.\n     *\n     * @param  length\n     *         The length of the subarray to be used;\n     *         must be non-negative and no larger than\n     *         {@code array.length - offset}.\n     *         The new buffer's limit will be set to {@code offset + length}.\n     *\n     * @return  The new byte buffer\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If the preconditions on the {@code offset} and {@code length}\n     *          parameters do not hold\n     ",
    "links" : [ "#array", "#arrayOffset", "java.nio.ByteOrder#BIG_ENDIAN" ]
  }, {
    "name" : "public static ByteBuffer wrap(byte[] array)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Wraps a byte array into a buffer.\n     *\n     * <p> The new buffer will be backed by the given byte array;\n     * that is, modifications to the buffer will cause the array to be modified\n     * and vice versa.  The new buffer's capacity and limit will be\n     * {@code array.length}, its position will be zero, its mark will be\n     * undefined, and its byte order will be\n\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\n\n\n\n\n     * Its {@link #array backing array} will be the given array, and its\n     * {@link #arrayOffset array offset} will be zero.  </p>\n     *\n     * @param  array\n     *         The array that will back this buffer\n     *\n     * @return  The new byte buffer\n     ",
    "links" : [ "#array", "#arrayOffset", "java.nio.ByteOrder#BIG_ENDIAN" ]
  }, {
    "name" : "public abstract ByteBuffer slice()",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Creates a new byte buffer whose content is a shared subsequence of\n     * this buffer's content.\n     *\n     * <p> The content of the new buffer will start at this buffer's current\n     * position.  Changes to this buffer's content will be visible in the new\n     * buffer, and vice versa; the two buffers' position, limit, and mark\n     * values will be independent.\n     *\n     * <p> The new buffer's position will be zero, its capacity and its limit\n     * will be the number of bytes remaining in this buffer, its mark will be\n     * undefined, and its byte order will be\n\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\n\n\n\n     * The new buffer will be direct if, and only if, this buffer is direct, and\n     * it will be read-only if, and only if, this buffer is read-only.  </p>\n     *\n     * @return  The new byte buffer\n\n     *\n     * @see #alignedSlice(int)\n\n     ",
    "links" : [ "java.nio.ByteOrder#BIG_ENDIAN" ]
  }, {
    "name" : "public abstract ByteBuffer slice(int index, int length)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Creates a new byte buffer whose content is a shared subsequence of\n     * this buffer's content.\n     *\n     * <p> The content of the new buffer will start at position {@code index}\n     * in this buffer, and will contain {@code length} elements. Changes to\n     * this buffer's content will be visible in the new buffer, and vice versa;\n     * the two buffers' position, limit, and mark values will be independent.\n     *\n     * <p> The new buffer's position will be zero, its capacity and its limit\n     * will be {@code length}, its mark will be undefined, and its byte order\n     * will be\n\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\n\n\n\n     * The new buffer will be direct if, and only if, this buffer is direct,\n     * and it will be read-only if, and only if, this buffer is read-only. </p>\n     *\n     * @param   index\n     *          The position in this buffer at which the content of the new\n     *          buffer will start; must be non-negative and no larger than\n     *          {@link #limit() limit()}\n     *\n     * @param   length\n     *          The number of elements the new buffer will contain; must be\n     *          non-negative and no larger than {@code limit() - index}\n     *\n     * @return  The new buffer\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative or greater than {@code limit()},\n     *          {@code length} is negative, or {@code length > limit() - index}\n     *\n     * @since 13\n     ",
    "links" : [ "#limit()", "java.nio.ByteOrder#BIG_ENDIAN" ]
  }, {
    "name" : "public abstract ByteBuffer duplicate()",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Creates a new byte buffer that shares this buffer's content.\n     *\n     * <p> The content of the new buffer will be that of this buffer.  Changes\n     * to this buffer's content will be visible in the new buffer, and vice\n     * versa; the two buffers' position, limit, and mark values will be\n     * independent.\n     *\n     * <p> The new buffer's capacity, limit, position,\n\n     * and mark values will be identical to those of this buffer, and its byte\n     * order will be {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\n\n\n\n     * The new buffer will be direct if, and only if, this buffer is direct, and\n     * it will be read-only if, and only if, this buffer is read-only.  </p>\n     *\n     * @return  The new byte buffer\n     ",
    "links" : [ "java.nio.ByteOrder#BIG_ENDIAN" ]
  }, {
    "name" : "public abstract ByteBuffer asReadOnlyBuffer()",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Creates a new, read-only byte buffer that shares this buffer's\n     * content.\n     *\n     * <p> The content of the new buffer will be that of this buffer.  Changes\n     * to this buffer's content will be visible in the new buffer; the new\n     * buffer itself, however, will be read-only and will not allow the shared\n     * content to be modified.  The two buffers' position, limit, and mark\n     * values will be independent.\n     *\n     * <p> The new buffer's capacity, limit, position,\n\n     * and mark values will be identical to those of this buffer, and its byte\n     * order will be {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\n\n\n\n     *\n     * <p> If this buffer is itself read-only then this method behaves in\n     * exactly the same way as the {@link #duplicate duplicate} method.  </p>\n     *\n     * @return  The new, read-only byte buffer\n     ",
    "links" : [ "#duplicate", "java.nio.ByteOrder#BIG_ENDIAN" ]
  }, {
    "name" : "public abstract byte get()",
    "returnType" : "byte",
    "comment" : "\n     * Relative <i>get</i> method.  Reads the byte at this buffer's\n     * current position, and then increments the position.\n     *\n     * @return  The byte at the buffer's current position\n     *\n     * @throws  BufferUnderflowException\n     *          If the buffer's current position is not smaller than its limit\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract ByteBuffer put(byte b)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Relative <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> Writes the given byte into this buffer at the current\n     * position, and then increments the position. </p>\n     *\n     * @param  b\n     *         The byte to be written\n     *\n     * @return  This buffer\n     *\n     * @throws  BufferOverflowException\n     *          If this buffer's current position is not smaller than its limit\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract byte get(int index)",
    "returnType" : "byte",
    "comment" : "\n     * Absolute <i>get</i> method.  Reads the byte at the given\n     * index.\n     *\n     * @param  index\n     *         The index from which the byte will be read\n     *\n     * @return  The byte at the given index\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative\n     *          or not smaller than the buffer's limit\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract ByteBuffer put(int index, byte b)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Absolute <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> Writes the given byte into this buffer at the given\n     * index. </p>\n     *\n     * @param  index\n     *         The index at which the byte will be written\n     *\n     * @param  b\n     *         The byte value to be written\n     *\n     * @return  This buffer\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative\n     *          or not smaller than the buffer's limit\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : "public ByteBuffer get(byte[] dst, int offset, int length)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Relative bulk <i>get</i> method.\n     *\n     * <p> This method transfers bytes from this buffer into the given\n     * destination array.  If there are fewer bytes remaining in the\n     * buffer than are required to satisfy the request, that is, if\n     * {@code length}&nbsp;{@code >}&nbsp;{@code remaining()}, then no\n     * bytes are transferred and a {@link BufferUnderflowException} is\n     * thrown.\n     *\n     * <p> Otherwise, this method copies {@code length} bytes from this\n     * buffer into the given array, starting at the current position of this\n     * buffer and at the given offset in the array.  The position of this\n     * buffer is then incremented by {@code length}.\n     *\n     * <p> In other words, an invocation of this method of the form\n     * <code>src.get(dst,&nbsp;off,&nbsp;len)</code> has exactly the same effect as\n     * the loop\n     *\n     * <pre>{@code\n     *     for (int i = off; i < off + len; i++)\n     *         dst[i] = src.get();\n     * }</pre>\n     *\n     * except that it first checks that there are sufficient bytes in\n     * this buffer and it is potentially much more efficient.\n     *\n     * @param  dst\n     *         The array into which bytes are to be written\n     *\n     * @param  offset\n     *         The offset within the array of the first byte to be\n     *         written; must be non-negative and no larger than\n     *         {@code dst.length}\n     *\n     * @param  length\n     *         The maximum number of bytes to be written to the given\n     *         array; must be non-negative and no larger than\n     *         {@code dst.length - offset}\n     *\n     * @return  This buffer\n     *\n     * @throws  BufferUnderflowException\n     *          If there are fewer than {@code length} bytes\n     *          remaining in this buffer\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If the preconditions on the {@code offset} and {@code length}\n     *          parameters do not hold\n     ",
    "links" : [ "java.nio.BufferUnderflowException" ]
  }, {
    "name" : "public ByteBuffer get(byte[] dst)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Relative bulk <i>get</i> method.\n     *\n     * <p> This method transfers bytes from this buffer into the given\n     * destination array.  An invocation of this method of the form\n     * {@code src.get(a)} behaves in exactly the same way as the invocation\n     *\n     * <pre>\n     *     src.get(a, 0, a.length) </pre>\n     *\n     * @param   dst\n     *          The destination array\n     *\n     * @return  This buffer\n     *\n     * @throws  BufferUnderflowException\n     *          If there are fewer than {@code length} bytes\n     *          remaining in this buffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public ByteBuffer get(int index, byte[] dst, int offset, int length)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Absolute bulk <i>get</i> method.\n     *\n     * <p> This method transfers {@code length} bytes from this\n     * buffer into the given array, starting at the given index in this\n     * buffer and at the given offset in the array.  The position of this\n     * buffer is unchanged.\n     *\n     * <p> An invocation of this method of the form\n     * <code>src.get(index,&nbsp;dst,&nbsp;offset,&nbsp;length)</code>\n     * has exactly the same effect as the following loop except that it first\n     * checks the consistency of the supplied parameters and it is potentially\n     * much more efficient:\n     *\n     * <pre>{@code\n     *     for (int i = offset, j = index; i < offset + length; i++, j++)\n     *         dst[i] = src.get(j);\n     * }</pre>\n     *\n     * @param  index\n     *         The index in this buffer from which the first byte will be\n     *         read; must be non-negative and less than {@code limit()}\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  offset\n     *         The offset within the array of the first byte to be\n     *         written; must be non-negative and less than\n     *         {@code dst.length}\n     *\n     * @param  length\n     *         The number of bytes to be written to the given array;\n     *         must be non-negative and no larger than the smaller of\n     *         {@code limit() - index} and {@code dst.length - offset}\n     *\n     * @return  This buffer\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If the preconditions on the {@code index}, {@code offset}, and\n     *          {@code length} parameters do not hold\n     *\n     * @since 13\n     ",
    "links" : [ ]
  }, {
    "name" : "public ByteBuffer get(int index, byte[] dst)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Absolute bulk <i>get</i> method.\n     *\n     * <p> This method transfers bytes from this buffer into the given\n     * destination array.  The position of this buffer is unchanged.  An\n     * invocation of this method of the form\n     * <code>src.get(index,&nbsp;dst)</code> behaves in exactly the same\n     * way as the invocation:\n     *\n     * <pre>\n     *     src.get(index, dst, 0, dst.length) </pre>\n     *\n     * @param  index\n     *         The index in this buffer from which the first byte will be\n     *         read; must be non-negative and less than {@code limit()}\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @return  This buffer\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative, not smaller than {@code limit()},\n     *          or {@code limit() - index < dst.length}\n     *\n     * @since 13\n     ",
    "links" : [ ]
  }, {
    "name" : "private ByteBuffer getArray(int index, byte[] dst, int offset, int length)",
    "returnType" : "ByteBuffer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ByteBuffer put(ByteBuffer src)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Relative bulk <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> This method transfers the bytes remaining in the given source\n     * buffer into this buffer.  If there are more bytes remaining in the\n     * source buffer than in this buffer, that is, if\n     * {@code src.remaining()}&nbsp;{@code >}&nbsp;{@code remaining()},\n     * then no bytes are transferred and a {@link\n     * BufferOverflowException} is thrown.\n     *\n     * <p> Otherwise, this method copies\n     * <i>n</i>&nbsp;=&nbsp;{@code src.remaining()} bytes from the given\n     * buffer into this buffer, starting at each buffer's current position.\n     * The positions of both buffers are then incremented by <i>n</i>.\n     *\n     * <p> In other words, an invocation of this method of the form\n     * {@code dst.put(src)} has exactly the same effect as the loop\n     *\n     * <pre>\n     *     while (src.hasRemaining())\n     *         dst.put(src.get()); </pre>\n     *\n     * except that it first checks that there is sufficient space in this\n     * buffer and it is potentially much more efficient.  If this buffer and\n     * the source buffer share the same backing array or memory, then the\n     * result will be as if the source elements were first copied to an\n     * intermediate location before being written into this buffer.\n     *\n     * @param  src\n     *         The source buffer from which bytes are to be read;\n     *         must not be this buffer\n     *\n     * @return  This buffer\n     *\n     * @throws  BufferOverflowException\n     *          If there is insufficient space in this buffer\n     *          for the remaining bytes in the source buffer\n     *\n     * @throws  IllegalArgumentException\n     *          If the source buffer is this buffer\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ "java.nio.BufferOverflowException" ]
  }, {
    "name" : "public ByteBuffer put(int index, ByteBuffer src, int offset, int length)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Absolute bulk <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> This method transfers {@code length} bytes into this buffer from\n     * the given source buffer, starting at the given {@code offset} in the\n     * source buffer and the given {@code index} in this buffer. The positions\n     * of both buffers are unchanged.\n     *\n     * <p> In other words, an invocation of this method of the form\n     * <code>dst.put(index,&nbsp;src,&nbsp;offset,&nbsp;length)</code>\n     * has exactly the same effect as the loop\n     *\n     * <pre>{@code\n     * for (int i = offset, j = index; i < offset + length; i++, j++)\n     *     dst.put(j, src.get(i));\n     * }</pre>\n     *\n     * except that it first checks the consistency of the supplied parameters\n     * and it is potentially much more efficient.  If this buffer and\n     * the source buffer share the same backing array or memory, then the\n     * result will be as if the source elements were first copied to an\n     * intermediate location before being written into this buffer.\n     *\n     * @param index\n     *        The index in this buffer at which the first byte will be\n     *        written; must be non-negative and less than {@code limit()}\n     *\n     * @param src\n     *        The buffer from which bytes are to be read\n     *\n     * @param offset\n     *        The index within the source buffer of the first byte to be\n     *        read; must be non-negative and less than {@code src.limit()}\n     *\n     * @param length\n     *        The number of bytes to be read from the given buffer;\n     *        must be non-negative and no larger than the smaller of\n     *        {@code limit() - index} and {@code src.limit() - offset}\n     *\n     * @return This buffer\n     *\n     * @throws IndexOutOfBoundsException\n     *         If the preconditions on the {@code index}, {@code offset}, and\n     *         {@code length} parameters do not hold\n     *\n     * @throws ReadOnlyBufferException\n     *         If this buffer is read-only\n     *\n     * @since 16\n     ",
    "links" : [ ]
  }, {
    "name" : " void putBuffer(int pos, ByteBuffer src, int srcPos, int n)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ByteBuffer put(byte[] src, int offset, int length)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Relative bulk <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> This method transfers bytes into this buffer from the given\n     * source array.  If there are more bytes to be copied from the array\n     * than remain in this buffer, that is, if\n     * {@code length}&nbsp;{@code >}&nbsp;{@code remaining()}, then no\n     * bytes are transferred and a {@link BufferOverflowException} is\n     * thrown.\n     *\n     * <p> Otherwise, this method copies {@code length} bytes from the\n     * given array into this buffer, starting at the given offset in the array\n     * and at the current position of this buffer.  The position of this buffer\n     * is then incremented by {@code length}.\n     *\n     * <p> In other words, an invocation of this method of the form\n     * <code>dst.put(src,&nbsp;off,&nbsp;len)</code> has exactly the same effect as\n     * the loop\n     *\n     * <pre>{@code\n     *     for (int i = off; i < off + len; i++)\n     *         dst.put(src[i]);\n     * }</pre>\n     *\n     * except that it first checks that there is sufficient space in this\n     * buffer and it is potentially much more efficient.\n     *\n     * @param  src\n     *         The array from which bytes are to be read\n     *\n     * @param  offset\n     *         The offset within the array of the first byte to be read;\n     *         must be non-negative and no larger than {@code src.length}\n     *\n     * @param  length\n     *         The number of bytes to be read from the given array;\n     *         must be non-negative and no larger than\n     *         {@code src.length - offset}\n     *\n     * @return  This buffer\n     *\n     * @throws  BufferOverflowException\n     *          If there is insufficient space in this buffer\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If the preconditions on the {@code offset} and {@code length}\n     *          parameters do not hold\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ "java.nio.BufferOverflowException" ]
  }, {
    "name" : "public final ByteBuffer put(byte[] src)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Relative bulk <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> This method transfers the entire content of the given source\n     * byte array into this buffer.  An invocation of this method of the\n     * form {@code dst.put(a)} behaves in exactly the same way as the\n     * invocation\n     *\n     * <pre>\n     *     dst.put(a, 0, a.length) </pre>\n     *\n     * @param   src\n     *          The source array\n     *\n     * @return  This buffer\n     *\n     * @throws  BufferOverflowException\n     *          If there is insufficient space in this buffer\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : "public ByteBuffer put(int index, byte[] src, int offset, int length)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Absolute bulk <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> This method transfers {@code length} bytes from the given\n     * array, starting at the given offset in the array and at the given index\n     * in this buffer.  The position of this buffer is unchanged.\n     *\n     * <p> An invocation of this method of the form\n     * <code>dst.put(index,&nbsp;src,&nbsp;offset,&nbsp;length)</code>\n     * has exactly the same effect as the following loop except that it first\n     * checks the consistency of the supplied parameters and it is potentially\n     * much more efficient:\n     *\n     * <pre>{@code\n     *     for (int i = offset, j = index; i < offset + length; i++, j++)\n     *         dst.put(j, src[i]);\n     * }</pre>\n     *\n     * @param  index\n     *         The index in this buffer at which the first byte will be\n     *         written; must be non-negative and less than {@code limit()}\n     *\n     * @param  src\n     *         The array from which bytes are to be read\n     *\n     * @param  offset\n     *         The offset within the array of the first byte to be read;\n     *         must be non-negative and less than {@code src.length}\n     *\n     * @param  length\n     *         The number of bytes to be read from the given array;\n     *         must be non-negative and no larger than the smaller of\n     *         {@code limit() - index} and {@code src.length - offset}\n     *\n     * @return  This buffer\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If the preconditions on the {@code index}, {@code offset}, and\n     *          {@code length} parameters do not hold\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     *\n     * @since 13\n     ",
    "links" : [ ]
  }, {
    "name" : "public ByteBuffer put(int index, byte[] src)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Absolute bulk <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> This method copies bytes into this buffer from the given source\n     * array.  The position of this buffer is unchanged.  An invocation of this\n     * method of the form <code>dst.put(index,&nbsp;src)</code>\n     * behaves in exactly the same way as the invocation:\n     *\n     * <pre>\n     *     dst.put(index, src, 0, src.length); </pre>\n     *\n     * @param  index\n     *         The index in this buffer at which the first byte will be\n     *         written; must be non-negative and less than {@code limit()}\n     *\n     * @param  src\n     *         The array from which bytes are to be read\n     *\n     * @return  This buffer\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative, not smaller than {@code limit()},\n     *          or {@code limit() - index < src.length}\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     *\n     * @since 13\n     ",
    "links" : [ ]
  }, {
    "name" : "private ByteBuffer putArray(int index, byte[] src, int offset, int length)",
    "returnType" : "ByteBuffer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final boolean hasArray()",
    "returnType" : "boolean",
    "comment" : "\n     * Tells whether or not this buffer is backed by an accessible byte\n     * array.\n     *\n     * <p> If this method returns {@code true} then the {@link #array() array}\n     * and {@link #arrayOffset() arrayOffset} methods may safely be invoked.\n     * </p>\n     *\n     * @return  {@code true} if, and only if, this buffer\n     *          is backed by an array and is not read-only\n     ",
    "links" : [ "#array()", "#arrayOffset()" ]
  }, {
    "name" : "public final byte[] array()",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns the byte array that backs this\n     * buffer&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> Modifications to this buffer's content will cause the returned\n     * array's content to be modified, and vice versa.\n     *\n     * <p> Invoke the {@link #hasArray hasArray} method before invoking this\n     * method in order to ensure that this buffer has an accessible backing\n     * array.  </p>\n     *\n     * @return  The array that backs this buffer\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is backed by an array but is read-only\n     *\n     * @throws  UnsupportedOperationException\n     *          If this buffer is not backed by an accessible array\n     ",
    "links" : [ "#hasArray" ]
  }, {
    "name" : "public final int arrayOffset()",
    "returnType" : "int",
    "comment" : "\n     * Returns the offset within this buffer's backing array of the first\n     * element of the buffer&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> If this buffer is backed by an array then buffer position <i>p</i>\n     * corresponds to array index <i>p</i>&nbsp;+&nbsp;{@code arrayOffset()}.\n     *\n     * <p> Invoke the {@link #hasArray hasArray} method before invoking this\n     * method in order to ensure that this buffer has an accessible backing\n     * array.  </p>\n     *\n     * @return  The offset within this buffer's array\n     *          of the first element of the buffer\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is backed by an array but is read-only\n     *\n     * @throws  UnsupportedOperationException\n     *          If this buffer is not backed by an accessible array\n     ",
    "links" : [ "#hasArray" ]
  }, {
    "name" : "public Buffer position(int newPosition)",
    "returnType" : "Buffer",
    "comment" : " Android-changed: Un-final the method until confirmation of causing no app compat.",
    "links" : [ ]
  }, {
    "name" : "public Buffer limit(int newLimit)",
    "returnType" : "Buffer",
    "comment" : " Android-changed: Un-final the method until confirmation of causing no app compat.",
    "links" : [ ]
  }, {
    "name" : "public Buffer mark()",
    "returnType" : "Buffer",
    "comment" : " Android-changed: Un-final the method until confirmation of causing no app compat.",
    "links" : [ ]
  }, {
    "name" : "public Buffer reset()",
    "returnType" : "Buffer",
    "comment" : " Android-changed: Un-final the method until confirmation of causing no app compat.",
    "links" : [ ]
  }, {
    "name" : "public Buffer clear()",
    "returnType" : "Buffer",
    "comment" : " Android-changed: Un-final the method until confirmation of causing no app compat.",
    "links" : [ ]
  }, {
    "name" : "public Buffer flip()",
    "returnType" : "Buffer",
    "comment" : " Android-changed: Un-final the method until confirmation of causing no app compat.",
    "links" : [ ]
  }, {
    "name" : "public Buffer rewind()",
    "returnType" : "Buffer",
    "comment" : " Android-changed: Un-final the method until confirmation of causing no app compat.",
    "links" : [ ]
  }, {
    "name" : "public abstract ByteBuffer compact()",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Compacts this buffer&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> The bytes between the buffer's current position and its limit,\n     * if any, are copied to the beginning of the buffer.  That is, the\n     * byte at index <i>p</i>&nbsp;=&nbsp;{@code position()} is copied\n     * to index zero, the byte at index <i>p</i>&nbsp;+&nbsp;1 is copied\n     * to index one, and so forth until the byte at index\n     * {@code limit()}&nbsp;-&nbsp;1 is copied to index\n     * <i>n</i>&nbsp;=&nbsp;{@code limit()}&nbsp;-&nbsp;{@code 1}&nbsp;-&nbsp;<i>p</i>.\n     * The buffer's position is then set to <i>n+1</i> and its limit is set to\n     * its capacity.  The mark, if defined, is discarded.\n     *\n     * <p> The buffer's position is set to the number of bytes copied,\n     * rather than to zero, so that an invocation of this method can be\n     * followed immediately by an invocation of another relative <i>put</i>\n     * method. </p>\n     *\n\n     *\n     * <p> Invoke this method after writing data from a buffer in case the\n     * write was incomplete.  The following loop, for example, copies bytes\n     * from one channel to another via the buffer {@code buf}:\n     *\n     * <blockquote><pre>{@code\n     *   buf.clear();          // Prepare buffer for use\n     *   while (in.read(buf) >= 0 || buf.position != 0) {\n     *       buf.flip();\n     *       out.write(buf);\n     *       buf.compact();    // In case of partial write\n     *   }\n     * }</pre></blockquote>\n     *\n\n     *\n     * @return  This buffer\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract boolean isDirect()",
    "returnType" : "boolean",
    "comment" : "\n     * Tells whether or not this byte buffer is direct.\n     *\n     * @return  {@code true} if, and only if, this buffer is direct\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string summarizing the state of this buffer.\n     *\n     * @return  A summary string\n     ",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current hash code of this buffer.\n     *\n     * <p> The hash code of a byte buffer depends only upon its remaining\n     * elements; that is, upon the elements from {@code position()} up to, and\n     * including, the element at {@code limit()}&nbsp;-&nbsp;{@code 1}.\n     *\n     * <p> Because buffer hash codes are content-dependent, it is inadvisable\n     * to use buffers as keys in hash maps or similar data structures unless it\n     * is known that their contents will not change.  </p>\n     *\n     * @return  The current hash code of this buffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object ob)",
    "returnType" : "boolean",
    "comment" : "\n     * Tells whether or not this buffer is equal to another object.\n     *\n     * <p> Two byte buffers are equal if, and only if,\n     *\n     * <ol>\n     *\n     *   <li><p> They have the same element type,  </p></li>\n     *\n     *   <li><p> They have the same number of remaining elements, and\n     *   </p></li>\n     *\n     *   <li><p> The two sequences of remaining elements, considered\n     *   independently of their starting positions, are pointwise equal.\n\n\n\n\n\n\n\n     *   </p></li>\n     *\n     * </ol>\n     *\n     * <p> A byte buffer is not equal to any other type of object.  </p>\n     *\n     * @param  ob  The object to which this buffer is to be compared\n     *\n     * @return  {@code true} if, and only if, this buffer is equal to the\n     *           given object\n     ",
    "links" : [ ]
  }, {
    "name" : "public int compareTo(ByteBuffer that)",
    "returnType" : "int",
    "comment" : "\n     * Compares this buffer to another.\n     *\n     * <p> Two byte buffers are compared by comparing their sequences of\n     * remaining elements lexicographically, without regard to the starting\n     * position of each sequence within its corresponding buffer.\n\n\n\n\n\n\n\n\n     * Pairs of {@code byte} elements are compared as if by invoking\n     * {@link Byte#compare(byte,byte)}.\n\n     *\n     * <p> A byte buffer is not comparable to any other type of object.\n     *\n     * @return  A negative integer, zero, or a positive integer as this buffer\n     *          is less than, equal to, or greater than the given buffer\n     ",
    "links" : [ "#compare(byte" ]
  }, {
    "name" : "private static int compare(byte x, byte y)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int mismatch(ByteBuffer that)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the relative index of the first mismatch between this\n     * buffer and a given buffer.  The index is relative to the\n     * {@link #position() position} of each buffer and will be in the range of\n     * 0 (inclusive) up to the smaller of the {@link #remaining() remaining}\n     * elements in each buffer (exclusive).\n     *\n     * <p> If the two buffers share a common prefix then the returned index is\n     * the length of the common prefix and it follows that there is a mismatch\n     * between the two buffers at that index within the respective buffers.\n     * If one buffer is a proper prefix of the other then the returned index is\n     * the smaller of the remaining elements in each buffer, and it follows that\n     * the index is only valid for the buffer with the larger number of\n     * remaining elements.\n     * Otherwise, there is no mismatch.\n     *\n     * @param  that\n     *         The byte buffer to be tested for a mismatch with this buffer\n     *\n     * @return  The relative index of the first mismatch between this and the\n     *          given buffer, otherwise -1 if no mismatch.\n     *\n     * @since 11\n     ",
    "links" : [ "#position()", "#remaining()" ]
  }, {
    "name" : "public final ByteOrder order()",
    "returnType" : "ByteOrder",
    "comment" : "\n     * Retrieves this buffer's byte order.\n     *\n     * <p> The byte order is used when reading or writing multibyte values, and\n     * when creating buffers that are views of this byte buffer.  The order of\n     * a newly-created byte buffer is always {@link ByteOrder#BIG_ENDIAN\n     * BIG_ENDIAN}.  </p>\n     *\n     * @return  This buffer's byte order\n     ",
    "links" : [ "java.nio.ByteOrder#BIG_ENDIANBIG_ENDIAN" ]
  }, {
    "name" : "public final ByteBuffer order(ByteOrder bo)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Modifies this buffer's byte order.\n     *\n     * @param  bo\n     *         The new byte order,\n     *         either {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}\n     *         or {@link ByteOrder#LITTLE_ENDIAN LITTLE_ENDIAN}\n     *\n     * @return  This buffer\n     ",
    "links" : [ "java.nio.ByteOrder#BIG_ENDIAN", "java.nio.ByteOrder#LITTLE_ENDIAN" ]
  }, {
    "name" : "public final int alignmentOffset(int index, int unitSize)",
    "returnType" : "int",
    "comment" : "\n     * Returns the memory address, pointing to the byte at the given index,\n     * modulo the given unit size.\n     *\n     * <p> The return value is non-negative in the range of {@code 0}\n     * (inclusive) up to {@code unitSize} (exclusive), with zero indicating\n     * that the address of the byte at the index is aligned for the unit size,\n     * and a positive value that the address is misaligned for the unit size.\n     * If the address of the byte at the index is misaligned, the return value\n     * represents how much the index should be adjusted to locate a byte at an\n     * aligned address.  Specifically, the index should either be decremented by\n     * the return value if the latter is not greater than {@code index}, or be\n     * incremented by the unit size minus the return value.  Therefore given\n     * <blockquote><pre>\n     * int value = alignmentOffset(index, unitSize)</pre></blockquote>\n     * then the identities\n     * <blockquote><pre>\n     * alignmentOffset(index - value, unitSize) == 0, value &le; index</pre></blockquote>\n     * and\n     * <blockquote><pre>\n     * alignmentOffset(index + (unitSize - value), unitSize) == 0</pre></blockquote>\n     * must hold.\n     *\n     * @apiNote\n     * This method may be utilized to determine if unit size bytes from an\n     * index can be accessed atomically, if supported by the native platform.\n     *\n     * @implNote\n     * This implementation throws {@code UnsupportedOperationException} for\n     * non-direct buffers when the given unit size is greater than {@code 8}.\n     *\n     * @param  index\n     *         The index to query for alignment offset, must be non-negative, no\n     *         upper bounds check is performed\n     *\n     * @param  unitSize\n     *         The unit size in bytes, must be a power of {@code 2}\n     *\n     * @return  The indexed byte's memory address modulo the unit size\n     *\n     * @throws IllegalArgumentException\n     *         If the index is negative or the unit size is not a power of\n     *         {@code 2}\n     *\n     * @throws UnsupportedOperationException\n     *         If the native platform does not guarantee stable alignment offset\n     *         values for the given unit size when managing the memory regions\n     *         of buffers of the same kind as this buffer (direct or\n     *         non-direct).  For example, if garbage collection would result\n     *         in the moving of a memory region covered by a non-direct buffer\n     *         from one location to another and both locations have different\n     *         alignment characteristics.\n     *\n     * @see #alignedSlice(int)\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public final ByteBuffer alignedSlice(int unitSize)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Creates a new byte buffer whose content is a shared and aligned\n     * subsequence of this buffer's content.\n     *\n     * <p> The content of the new buffer will start at this buffer's current\n     * position rounded up to the index of the nearest aligned byte for the\n     * given unit size, and end at this buffer's limit rounded down to the index\n     * of the nearest aligned byte for the given unit size.\n     * If rounding results in out-of-bound values then the new buffer's capacity\n     * and limit will be zero.  If rounding is within bounds the following\n     * expressions will be true for a new buffer {@code nb} and unit size\n     * {@code unitSize}:\n     * <pre>{@code\n     * nb.alignmentOffset(0, unitSize) == 0\n     * nb.alignmentOffset(nb.limit(), unitSize) == 0\n     * }</pre>\n     *\n     * <p> Changes to this buffer's content will be visible in the new\n     * buffer, and vice versa; the two buffers' position, limit, and mark\n     * values will be independent.\n     *\n     * <p> The new buffer's position will be zero, its capacity and its limit\n     * will be the number of bytes remaining in this buffer or fewer subject to\n     * alignment, its mark will be undefined, and its byte order will be\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\n     *\n     * The new buffer will be direct if, and only if, this buffer is direct, and\n     * it will be read-only if, and only if, this buffer is read-only.  </p>\n     *\n     * @apiNote\n     * This method may be utilized to create a new buffer where unit size bytes\n     * from index, that is a multiple of the unit size, may be accessed\n     * atomically, if supported by the native platform.\n     *\n     * @implNote\n     * This implementation throws {@code UnsupportedOperationException} for\n     * non-direct buffers when the given unit size is greater than {@code 8}.\n     *\n     * @param  unitSize\n     *         The unit size in bytes, must be a power of {@code 2}\n     *\n     * @return  The new byte buffer\n     *\n     * @throws IllegalArgumentException\n     *         If the unit size not a power of {@code 2}\n     *\n     * @throws UnsupportedOperationException\n     *         If the native platform does not guarantee stable aligned slices\n     *         for the given unit size when managing the memory regions\n     *         of buffers of the same kind as this buffer (direct or\n     *         non-direct).  For example, if garbage collection would result\n     *         in the moving of a memory region covered by a non-direct buffer\n     *         from one location to another and both locations have different\n     *         alignment characteristics.\n     *\n     * @see #alignmentOffset(int, int)\n     * @see #slice()\n     * @since 9\n     ",
    "links" : [ "java.nio.ByteOrder#BIG_ENDIAN" ]
  }, {
    "name" : " abstract byte _get(int i)",
    "returnType" : "byte",
    "comment" : " package-private",
    "links" : [ ]
  }, {
    "name" : " abstract void _put(int i, byte b)",
    "returnType" : "void",
    "comment" : " package-private",
    "links" : [ ]
  }, {
    "name" : "public boolean isAccessible()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAccessible(boolean value)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract char getChar()",
    "returnType" : "char",
    "comment" : "\n     * Relative <i>get</i> method for reading a char value.\n     *\n     * <p> Reads the next two bytes at this buffer's current position,\n     * composing them into a char value according to the current byte order,\n     * and then increments the position by two.  </p>\n     *\n     * @return  The char value at the buffer's current position\n     *\n     * @throws  BufferUnderflowException\n     *          If there are fewer than two bytes\n     *          remaining in this buffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract ByteBuffer putChar(char value)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Relative <i>put</i> method for writing a char\n     * value&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> Writes two bytes containing the given char value, in the\n     * current byte order, into this buffer at the current position, and then\n     * increments the position by two.  </p>\n     *\n     * @param  value\n     *         The char value to be written\n     *\n     * @return  This buffer\n     *\n     * @throws  BufferOverflowException\n     *          If there are fewer than two bytes\n     *          remaining in this buffer\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract char getChar(int index)",
    "returnType" : "char",
    "comment" : "\n     * Absolute <i>get</i> method for reading a char value.\n     *\n     * <p> Reads two bytes at the given index, composing them into a\n     * char value according to the current byte order.  </p>\n     *\n     * @param  index\n     *         The index from which the bytes will be read\n     *\n     * @return  The char value at the given index\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative\n     *          or not smaller than the buffer's limit,\n     *          minus one\n     ",
    "links" : [ ]
  }, {
    "name" : " abstract char getCharUnchecked(int index)",
    "returnType" : "char",
    "comment" : " BEGIN Android-added: {get,put}*Unchecked() accessors.",
    "links" : [ ]
  }, {
    "name" : " abstract void getUnchecked(int pos, char[] dst, int dstOffset, int length)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public abstract ByteBuffer putChar(int index, char value)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Absolute <i>put</i> method for writing a char\n     * value&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> Writes two bytes containing the given char value, in the\n     * current byte order, into this buffer at the given index.  </p>\n     *\n     * @param  index\n     *         The index at which the bytes will be written\n     *\n     * @param  value\n     *         The char value to be written\n     *\n     * @return  This buffer\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative\n     *          or not smaller than the buffer's limit,\n     *          minus one\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : " abstract void putCharUnchecked(int index, char value)",
    "returnType" : "void",
    "comment" : " BEGIN Android-added: {get,put}*Unchecked() accessors.",
    "links" : [ ]
  }, {
    "name" : " abstract void putUnchecked(int pos, char[] dst, int srcOffset, int length)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public abstract CharBuffer asCharBuffer()",
    "returnType" : "CharBuffer",
    "comment" : "\n     * Creates a view of this byte buffer as a char buffer.\n     *\n     * <p> The content of the new buffer will start at this buffer's current\n     * position.  Changes to this buffer's content will be visible in the new\n     * buffer, and vice versa; the two buffers' position, limit, and mark\n     * values will be independent.\n     *\n     * <p> The new buffer's position will be zero, its capacity and its limit\n     * will be the number of bytes remaining in this buffer divided by\n     * two, its mark will be undefined, and its byte order will be that\n     * of the byte buffer at the moment the view is created.  The new buffer\n     * will be direct if, and only if, this buffer is direct, and it will be\n     * read-only if, and only if, this buffer is read-only.  </p>\n     *\n     * @return  A new char buffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract short getShort()",
    "returnType" : "short",
    "comment" : "\n     * Relative <i>get</i> method for reading a short value.\n     *\n     * <p> Reads the next two bytes at this buffer's current position,\n     * composing them into a short value according to the current byte order,\n     * and then increments the position by two.  </p>\n     *\n     * @return  The short value at the buffer's current position\n     *\n     * @throws  BufferUnderflowException\n     *          If there are fewer than two bytes\n     *          remaining in this buffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract ByteBuffer putShort(short value)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Relative <i>put</i> method for writing a short\n     * value&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> Writes two bytes containing the given short value, in the\n     * current byte order, into this buffer at the current position, and then\n     * increments the position by two.  </p>\n     *\n     * @param  value\n     *         The short value to be written\n     *\n     * @return  This buffer\n     *\n     * @throws  BufferOverflowException\n     *          If there are fewer than two bytes\n     *          remaining in this buffer\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract short getShort(int index)",
    "returnType" : "short",
    "comment" : "\n     * Absolute <i>get</i> method for reading a short value.\n     *\n     * <p> Reads two bytes at the given index, composing them into a\n     * short value according to the current byte order.  </p>\n     *\n     * @param  index\n     *         The index from which the bytes will be read\n     *\n     * @return  The short value at the given index\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative\n     *          or not smaller than the buffer's limit,\n     *          minus one\n     ",
    "links" : [ ]
  }, {
    "name" : " abstract short getShortUnchecked(int index)",
    "returnType" : "short",
    "comment" : " BEGIN Android-added: {get,put}*Unchecked() accessors.",
    "links" : [ ]
  }, {
    "name" : " abstract void getUnchecked(int pos, short[] dst, int dstOffset, int length)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public abstract ByteBuffer putShort(int index, short value)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Absolute <i>put</i> method for writing a short\n     * value&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> Writes two bytes containing the given short value, in the\n     * current byte order, into this buffer at the given index.  </p>\n     *\n     * @param  index\n     *         The index at which the bytes will be written\n     *\n     * @param  value\n     *         The short value to be written\n     *\n     * @return  This buffer\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative\n     *          or not smaller than the buffer's limit,\n     *          minus one\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : " abstract void putShortUnchecked(int index, short value)",
    "returnType" : "void",
    "comment" : " BEGIN Android-added: {get,put}*Unchecked() accessors.",
    "links" : [ ]
  }, {
    "name" : " abstract void putUnchecked(int pos, short[] dst, int srcOffset, int length)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public abstract ShortBuffer asShortBuffer()",
    "returnType" : "ShortBuffer",
    "comment" : "\n     * Creates a view of this byte buffer as a short buffer.\n     *\n     * <p> The content of the new buffer will start at this buffer's current\n     * position.  Changes to this buffer's content will be visible in the new\n     * buffer, and vice versa; the two buffers' position, limit, and mark\n     * values will be independent.\n     *\n     * <p> The new buffer's position will be zero, its capacity and its limit\n     * will be the number of bytes remaining in this buffer divided by\n     * two, its mark will be undefined, and its byte order will be that\n     * of the byte buffer at the moment the view is created.  The new buffer\n     * will be direct if, and only if, this buffer is direct, and it will be\n     * read-only if, and only if, this buffer is read-only.  </p>\n     *\n     * @return  A new short buffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract int getInt()",
    "returnType" : "int",
    "comment" : "\n     * Relative <i>get</i> method for reading an int value.\n     *\n     * <p> Reads the next four bytes at this buffer's current position,\n     * composing them into an int value according to the current byte order,\n     * and then increments the position by four.  </p>\n     *\n     * @return  The int value at the buffer's current position\n     *\n     * @throws  BufferUnderflowException\n     *          If there are fewer than four bytes\n     *          remaining in this buffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract ByteBuffer putInt(int value)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Relative <i>put</i> method for writing an int\n     * value&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> Writes four bytes containing the given int value, in the\n     * current byte order, into this buffer at the current position, and then\n     * increments the position by four.  </p>\n     *\n     * @param  value\n     *         The int value to be written\n     *\n     * @return  This buffer\n     *\n     * @throws  BufferOverflowException\n     *          If there are fewer than four bytes\n     *          remaining in this buffer\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract int getInt(int index)",
    "returnType" : "int",
    "comment" : "\n     * Absolute <i>get</i> method for reading an int value.\n     *\n     * <p> Reads four bytes at the given index, composing them into a\n     * int value according to the current byte order.  </p>\n     *\n     * @param  index\n     *         The index from which the bytes will be read\n     *\n     * @return  The int value at the given index\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative\n     *          or not smaller than the buffer's limit,\n     *          minus three\n     ",
    "links" : [ ]
  }, {
    "name" : " abstract int getIntUnchecked(int index)",
    "returnType" : "int",
    "comment" : " BEGIN Android-added: {get,put}*Unchecked() accessors.",
    "links" : [ ]
  }, {
    "name" : " abstract void getUnchecked(int pos, int[] dst, int dstOffset, int length)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public abstract ByteBuffer putInt(int index, int value)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Absolute <i>put</i> method for writing an int\n     * value&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> Writes four bytes containing the given int value, in the\n     * current byte order, into this buffer at the given index.  </p>\n     *\n     * @param  index\n     *         The index at which the bytes will be written\n     *\n     * @param  value\n     *         The int value to be written\n     *\n     * @return  This buffer\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative\n     *          or not smaller than the buffer's limit,\n     *          minus three\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : " abstract void putIntUnchecked(int index, int value)",
    "returnType" : "void",
    "comment" : " BEGIN Android-added: {get,put}*Unchecked() accessors.",
    "links" : [ ]
  }, {
    "name" : " abstract void putUnchecked(int pos, int[] dst, int srcOffset, int length)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public abstract IntBuffer asIntBuffer()",
    "returnType" : "IntBuffer",
    "comment" : "\n     * Creates a view of this byte buffer as an int buffer.\n     *\n     * <p> The content of the new buffer will start at this buffer's current\n     * position.  Changes to this buffer's content will be visible in the new\n     * buffer, and vice versa; the two buffers' position, limit, and mark\n     * values will be independent.\n     *\n     * <p> The new buffer's position will be zero, its capacity and its limit\n     * will be the number of bytes remaining in this buffer divided by\n     * four, its mark will be undefined, and its byte order will be that\n     * of the byte buffer at the moment the view is created.  The new buffer\n     * will be direct if, and only if, this buffer is direct, and it will be\n     * read-only if, and only if, this buffer is read-only.  </p>\n     *\n     * @return  A new int buffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract long getLong()",
    "returnType" : "long",
    "comment" : "\n     * Relative <i>get</i> method for reading a long value.\n     *\n     * <p> Reads the next eight bytes at this buffer's current position,\n     * composing them into a long value according to the current byte order,\n     * and then increments the position by eight.  </p>\n     *\n     * @return  The long value at the buffer's current position\n     *\n     * @throws  BufferUnderflowException\n     *          If there are fewer than eight bytes\n     *          remaining in this buffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract ByteBuffer putLong(long value)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Relative <i>put</i> method for writing a long\n     * value&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> Writes eight bytes containing the given long value, in the\n     * current byte order, into this buffer at the current position, and then\n     * increments the position by eight.  </p>\n     *\n     * @param  value\n     *         The long value to be written\n     *\n     * @return  This buffer\n     *\n     * @throws  BufferOverflowException\n     *          If there are fewer than eight bytes\n     *          remaining in this buffer\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract long getLong(int index)",
    "returnType" : "long",
    "comment" : "\n     * Absolute <i>get</i> method for reading a long value.\n     *\n     * <p> Reads eight bytes at the given index, composing them into a\n     * long value according to the current byte order.  </p>\n     *\n     * @param  index\n     *         The index from which the bytes will be read\n     *\n     * @return  The long value at the given index\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative\n     *          or not smaller than the buffer's limit,\n     *          minus seven\n     ",
    "links" : [ ]
  }, {
    "name" : " abstract long getLongUnchecked(int index)",
    "returnType" : "long",
    "comment" : " BEGIN Android-added: {get,put}*Unchecked() accessors.",
    "links" : [ ]
  }, {
    "name" : " abstract void getUnchecked(int pos, long[] dst, int dstOffset, int length)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public abstract ByteBuffer putLong(int index, long value)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Absolute <i>put</i> method for writing a long\n     * value&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> Writes eight bytes containing the given long value, in the\n     * current byte order, into this buffer at the given index.  </p>\n     *\n     * @param  index\n     *         The index at which the bytes will be written\n     *\n     * @param  value\n     *         The long value to be written\n     *\n     * @return  This buffer\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative\n     *          or not smaller than the buffer's limit,\n     *          minus seven\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : " abstract void putLongUnchecked(int index, long value)",
    "returnType" : "void",
    "comment" : " BEGIN Android-added: {get,put}*Unchecked() accessors.",
    "links" : [ ]
  }, {
    "name" : " abstract void putUnchecked(int pos, long[] dst, int srcOffset, int length)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public abstract LongBuffer asLongBuffer()",
    "returnType" : "LongBuffer",
    "comment" : "\n     * Creates a view of this byte buffer as a long buffer.\n     *\n     * <p> The content of the new buffer will start at this buffer's current\n     * position.  Changes to this buffer's content will be visible in the new\n     * buffer, and vice versa; the two buffers' position, limit, and mark\n     * values will be independent.\n     *\n     * <p> The new buffer's position will be zero, its capacity and its limit\n     * will be the number of bytes remaining in this buffer divided by\n     * eight, its mark will be undefined, and its byte order will be that\n     * of the byte buffer at the moment the view is created.  The new buffer\n     * will be direct if, and only if, this buffer is direct, and it will be\n     * read-only if, and only if, this buffer is read-only.  </p>\n     *\n     * @return  A new long buffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract float getFloat()",
    "returnType" : "float",
    "comment" : "\n     * Relative <i>get</i> method for reading a float value.\n     *\n     * <p> Reads the next four bytes at this buffer's current position,\n     * composing them into a float value according to the current byte order,\n     * and then increments the position by four.  </p>\n     *\n     * @return  The float value at the buffer's current position\n     *\n     * @throws  BufferUnderflowException\n     *          If there are fewer than four bytes\n     *          remaining in this buffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract ByteBuffer putFloat(float value)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Relative <i>put</i> method for writing a float\n     * value&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> Writes four bytes containing the given float value, in the\n     * current byte order, into this buffer at the current position, and then\n     * increments the position by four.  </p>\n     *\n     * @param  value\n     *         The float value to be written\n     *\n     * @return  This buffer\n     *\n     * @throws  BufferOverflowException\n     *          If there are fewer than four bytes\n     *          remaining in this buffer\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract float getFloat(int index)",
    "returnType" : "float",
    "comment" : "\n     * Absolute <i>get</i> method for reading a float value.\n     *\n     * <p> Reads four bytes at the given index, composing them into a\n     * float value according to the current byte order.  </p>\n     *\n     * @param  index\n     *         The index from which the bytes will be read\n     *\n     * @return  The float value at the given index\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative\n     *          or not smaller than the buffer's limit,\n     *          minus three\n     ",
    "links" : [ ]
  }, {
    "name" : " abstract float getFloatUnchecked(int index)",
    "returnType" : "float",
    "comment" : " BEGIN Android-added: {get,put}*Unchecked() accessors.",
    "links" : [ ]
  }, {
    "name" : " abstract void getUnchecked(int pos, float[] dst, int dstOffset, int length)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public abstract ByteBuffer putFloat(int index, float value)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Absolute <i>put</i> method for writing a float\n     * value&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> Writes four bytes containing the given float value, in the\n     * current byte order, into this buffer at the given index.  </p>\n     *\n     * @param  index\n     *         The index at which the bytes will be written\n     *\n     * @param  value\n     *         The float value to be written\n     *\n     * @return  This buffer\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative\n     *          or not smaller than the buffer's limit,\n     *          minus three\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : " abstract void putFloatUnchecked(int index, float value)",
    "returnType" : "void",
    "comment" : " BEGIN Android-added: {get,put}*Unchecked() accessors.",
    "links" : [ ]
  }, {
    "name" : " abstract void putUnchecked(int pos, float[] dst, int srcOffset, int length)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public abstract FloatBuffer asFloatBuffer()",
    "returnType" : "FloatBuffer",
    "comment" : "\n     * Creates a view of this byte buffer as a float buffer.\n     *\n     * <p> The content of the new buffer will start at this buffer's current\n     * position.  Changes to this buffer's content will be visible in the new\n     * buffer, and vice versa; the two buffers' position, limit, and mark\n     * values will be independent.\n     *\n     * <p> The new buffer's position will be zero, its capacity and its limit\n     * will be the number of bytes remaining in this buffer divided by\n     * four, its mark will be undefined, and its byte order will be that\n     * of the byte buffer at the moment the view is created.  The new buffer\n     * will be direct if, and only if, this buffer is direct, and it will be\n     * read-only if, and only if, this buffer is read-only.  </p>\n     *\n     * @return  A new float buffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract double getDouble()",
    "returnType" : "double",
    "comment" : "\n     * Relative <i>get</i> method for reading a double value.\n     *\n     * <p> Reads the next eight bytes at this buffer's current position,\n     * composing them into a double value according to the current byte order,\n     * and then increments the position by eight.  </p>\n     *\n     * @return  The double value at the buffer's current position\n     *\n     * @throws  BufferUnderflowException\n     *          If there are fewer than eight bytes\n     *          remaining in this buffer\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract ByteBuffer putDouble(double value)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Relative <i>put</i> method for writing a double\n     * value&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> Writes eight bytes containing the given double value, in the\n     * current byte order, into this buffer at the current position, and then\n     * increments the position by eight.  </p>\n     *\n     * @param  value\n     *         The double value to be written\n     *\n     * @return  This buffer\n     *\n     * @throws  BufferOverflowException\n     *          If there are fewer than eight bytes\n     *          remaining in this buffer\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract double getDouble(int index)",
    "returnType" : "double",
    "comment" : "\n     * Absolute <i>get</i> method for reading a double value.\n     *\n     * <p> Reads eight bytes at the given index, composing them into a\n     * double value according to the current byte order.  </p>\n     *\n     * @param  index\n     *         The index from which the bytes will be read\n     *\n     * @return  The double value at the given index\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative\n     *          or not smaller than the buffer's limit,\n     *          minus seven\n     ",
    "links" : [ ]
  }, {
    "name" : " abstract double getDoubleUnchecked(int index)",
    "returnType" : "double",
    "comment" : " BEGIN Android-added: {get,put}*Unchecked() accessors.",
    "links" : [ ]
  }, {
    "name" : " abstract void getUnchecked(int pos, double[] dst, int dstOffset, int length)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public abstract ByteBuffer putDouble(int index, double value)",
    "returnType" : "ByteBuffer",
    "comment" : "\n     * Absolute <i>put</i> method for writing a double\n     * value&nbsp;&nbsp;<i>(optional operation)</i>.\n     *\n     * <p> Writes eight bytes containing the given double value, in the\n     * current byte order, into this buffer at the given index.  </p>\n     *\n     * @param  index\n     *         The index at which the bytes will be written\n     *\n     * @param  value\n     *         The double value to be written\n     *\n     * @return  This buffer\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code index} is negative\n     *          or not smaller than the buffer's limit,\n     *          minus seven\n     *\n     * @throws  ReadOnlyBufferException\n     *          If this buffer is read-only\n     ",
    "links" : [ ]
  }, {
    "name" : " abstract void putDoubleUnchecked(int index, double value)",
    "returnType" : "void",
    "comment" : " BEGIN Android-added: {get,put}*Unchecked() accessors.",
    "links" : [ ]
  }, {
    "name" : " abstract void putUnchecked(int pos, double[] dst, int srcOffset, int length)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public abstract DoubleBuffer asDoubleBuffer()",
    "returnType" : "DoubleBuffer",
    "comment" : "\n     * Creates a view of this byte buffer as a double buffer.\n     *\n     * <p> The content of the new buffer will start at this buffer's current\n     * position.  Changes to this buffer's content will be visible in the new\n     * buffer, and vice versa; the two buffers' position, limit, and mark\n     * values will be independent.\n     *\n     * <p> The new buffer's position will be zero, its capacity and its limit\n     * will be the number of bytes remaining in this buffer divided by\n     * eight, its mark will be undefined, and its byte order will be that\n     * of the byte buffer at the moment the view is created.  The new buffer\n     * will be direct if, and only if, this buffer is direct, and it will be\n     * read-only if, and only if, this buffer is read-only.  </p>\n     *\n     * @return  A new double buffer\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " Object base()", "public static ByteBuffer allocateDirect(int capacity)", "public static ByteBuffer allocate(int capacity)", "public static ByteBuffer wrap(byte[] array, int offset, int length)", "public static ByteBuffer wrap(byte[] array)", "public abstract ByteBuffer slice()", "public abstract ByteBuffer slice(int index, int length)", "public abstract ByteBuffer duplicate()", "public abstract ByteBuffer asReadOnlyBuffer()", "public abstract byte get()", "public abstract ByteBuffer put(byte b)", "public abstract byte get(int index)", "public abstract ByteBuffer put(int index, byte b)", "public ByteBuffer get(byte[] dst, int offset, int length)", "public ByteBuffer get(byte[] dst)", "public ByteBuffer get(int index, byte[] dst, int offset, int length)", "public ByteBuffer get(int index, byte[] dst)", "private ByteBuffer getArray(int index, byte[] dst, int offset, int length)", "public ByteBuffer put(ByteBuffer src)", "public ByteBuffer put(int index, ByteBuffer src, int offset, int length)", " void putBuffer(int pos, ByteBuffer src, int srcPos, int n)", "public ByteBuffer put(byte[] src, int offset, int length)", "public final ByteBuffer put(byte[] src)", "public ByteBuffer put(int index, byte[] src, int offset, int length)", "public ByteBuffer put(int index, byte[] src)", "private ByteBuffer putArray(int index, byte[] src, int offset, int length)", "public final boolean hasArray()", "public final byte[] array()", "public final int arrayOffset()", "public Buffer position(int newPosition)", "public Buffer limit(int newLimit)", "public Buffer mark()", "public Buffer reset()", "public Buffer clear()", "public Buffer flip()", "public Buffer rewind()", "public abstract ByteBuffer compact()", "public abstract boolean isDirect()", "public String toString()", "public int hashCode()", "public boolean equals(Object ob)", "public int compareTo(ByteBuffer that)", "private static int compare(byte x, byte y)", "public int mismatch(ByteBuffer that)", "public final ByteOrder order()", "public final ByteBuffer order(ByteOrder bo)", "public final int alignmentOffset(int index, int unitSize)", "public final ByteBuffer alignedSlice(int unitSize)", " abstract byte _get(int i)", " abstract void _put(int i, byte b)", "public boolean isAccessible()", "public void setAccessible(boolean value)", "public abstract char getChar()", "public abstract ByteBuffer putChar(char value)", "public abstract char getChar(int index)", " abstract char getCharUnchecked(int index)", " abstract void getUnchecked(int pos, char[] dst, int dstOffset, int length)", "public abstract ByteBuffer putChar(int index, char value)", " abstract void putCharUnchecked(int index, char value)", " abstract void putUnchecked(int pos, char[] dst, int srcOffset, int length)", "public abstract CharBuffer asCharBuffer()", "public abstract short getShort()", "public abstract ByteBuffer putShort(short value)", "public abstract short getShort(int index)", " abstract short getShortUnchecked(int index)", " abstract void getUnchecked(int pos, short[] dst, int dstOffset, int length)", "public abstract ByteBuffer putShort(int index, short value)", " abstract void putShortUnchecked(int index, short value)", " abstract void putUnchecked(int pos, short[] dst, int srcOffset, int length)", "public abstract ShortBuffer asShortBuffer()", "public abstract int getInt()", "public abstract ByteBuffer putInt(int value)", "public abstract int getInt(int index)", " abstract int getIntUnchecked(int index)", " abstract void getUnchecked(int pos, int[] dst, int dstOffset, int length)", "public abstract ByteBuffer putInt(int index, int value)", " abstract void putIntUnchecked(int index, int value)", " abstract void putUnchecked(int pos, int[] dst, int srcOffset, int length)", "public abstract IntBuffer asIntBuffer()", "public abstract long getLong()", "public abstract ByteBuffer putLong(long value)", "public abstract long getLong(int index)", " abstract long getLongUnchecked(int index)", " abstract void getUnchecked(int pos, long[] dst, int dstOffset, int length)", "public abstract ByteBuffer putLong(int index, long value)", " abstract void putLongUnchecked(int index, long value)", " abstract void putUnchecked(int pos, long[] dst, int srcOffset, int length)", "public abstract LongBuffer asLongBuffer()", "public abstract float getFloat()", "public abstract ByteBuffer putFloat(float value)", "public abstract float getFloat(int index)", " abstract float getFloatUnchecked(int index)", " abstract void getUnchecked(int pos, float[] dst, int dstOffset, int length)", "public abstract ByteBuffer putFloat(int index, float value)", " abstract void putFloatUnchecked(int index, float value)", " abstract void putUnchecked(int pos, float[] dst, int srcOffset, int length)", "public abstract FloatBuffer asFloatBuffer()", "public abstract double getDouble()", "public abstract ByteBuffer putDouble(double value)", "public abstract double getDouble(int index)", " abstract double getDoubleUnchecked(int index)", " abstract void getUnchecked(int pos, double[] dst, int dstOffset, int length)", "public abstract ByteBuffer putDouble(int index, double value)", " abstract void putDoubleUnchecked(int index, double value)", " abstract void putUnchecked(int pos, double[] dst, int srcOffset, int length)", "public abstract DoubleBuffer asDoubleBuffer()" ],
  "variableNames" : [ "ARRAY_BASE_OFFSET", "hb", "offset", "isReadOnly", "ELEMENT_SIZE_SHIFT", "bigEndian", "nativeByteOrder" ]
}