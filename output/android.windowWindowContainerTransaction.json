{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/window/WindowContainerTransaction.java",
  "packageName" : "android.window",
  "className" : "WindowContainerTransaction",
  "comment" : "\n * Represents a collection of operations on some WindowContainers that should be applied all at\n * once.\n *\n * @hide\n ",
  "variables" : [ {
    "name" : "mChanges",
    "type" : "ArrayMap<IBinder, Change>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHierarchyOps",
    "type" : "ArrayList<HierarchyOp>",
    "comment" : " Flat list because re-order operations are order-dependent",
    "links" : [ ]
  }, {
    "name" : "CREATOR",
    "type" : "Creator<WindowContainerTransaction>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private Change getOrCreateChange(IBinder token)",
    "returnType" : "Change",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public WindowContainerTransaction setBounds(@NonNull WindowContainerToken container, @NonNull Rect bounds)",
    "returnType" : "WindowContainerTransaction",
    "comment" : "\n     * Resize a container.\n     ",
    "links" : [ ]
  }, {
    "name" : "public WindowContainerTransaction setAppBounds(@NonNull WindowContainerToken container, @NonNull Rect appBounds)",
    "returnType" : "WindowContainerTransaction",
    "comment" : "\n     * Resize a container's app bounds. This is the bounds used to report appWidth/Height to an\n     * app's DisplayInfo. It is derived by subtracting the overlapping portion of the navbar from\n     * the full bounds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public WindowContainerTransaction setScreenSizeDp(@NonNull WindowContainerToken container, int w, int h)",
    "returnType" : "WindowContainerTransaction",
    "comment" : "\n     * Resize a container's configuration size. The configuration size is what gets reported to the\n     * app via screenWidth/HeightDp and influences which resources get loaded. This size is\n     * derived by subtracting the overlapping portions of both the statusbar and the navbar from\n     * the full bounds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public WindowContainerTransaction scheduleFinishEnterPip(@NonNull WindowContainerToken container, @NonNull Rect bounds)",
    "returnType" : "WindowContainerTransaction",
    "comment" : "\n     * Notify activities within the hierarchy of a container that they have entered picture-in-picture\n     * mode with the given bounds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public WindowContainerTransaction setBoundsChangeTransaction(@NonNull WindowContainerToken container, @NonNull SurfaceControl.Transaction t)",
    "returnType" : "WindowContainerTransaction",
    "comment" : "\n     * Send a SurfaceControl transaction to the server, which the server will apply in sync with\n     * the next bounds change. As this uses deferred transaction and not BLAST it is only\n     * able to sync with a single window, and the first visible window in this hierarchy of type\n     * BASE_APPLICATION to resize will be used. If there are bound changes included in this\n     * WindowContainer transaction (from setBounds or scheduleFinishEnterPip), the SurfaceControl\n     * transaction will be synced with those bounds. If there are no changes, then\n     * the SurfaceControl transaction will be synced with the next bounds change. This means\n     * that you can call this, apply the WindowContainer transaction, and then later call\n     * dismissPip() to achieve synchronization.\n     ",
    "links" : [ ]
  }, {
    "name" : "public WindowContainerTransaction setBoundsChangeTransaction(@NonNull WindowContainerToken task, @NonNull Rect surfaceBounds)",
    "returnType" : "WindowContainerTransaction",
    "comment" : "\n     * Like {@link #setBoundsChangeTransaction} but instead queues up a setPosition/WindowCrop\n     * on a container's surface control. This is useful when a boundsChangeTransaction needs to be\n     * queued up on a Task that won't be organized until the end of this window-container\n     * transaction.\n     *\n     * This requires that, at the end of this transaction, `task` will be organized; otherwise\n     * the server will throw an IllegalArgumentException.\n     *\n     * WARNING: Use this carefully. Whatever is set here should match the expected bounds after\n     *          the transaction completes since it will likely be replaced by it. This call is\n     *          intended to pre-emptively set bounds on a surface in sync with a buffer when\n     *          otherwise the new bounds and the new buffer would update on different frames.\n     *\n     * TODO(b/134365562): remove once TaskOrg drives full-screen or BLAST is enabled.\n     *\n     * @hide\n     ",
    "links" : [ "#setBoundsChangeTransaction" ]
  }, {
    "name" : "public WindowContainerTransaction setActivityWindowingMode(@NonNull WindowContainerToken container, int windowingMode)",
    "returnType" : "WindowContainerTransaction",
    "comment" : "\n     * Set the windowing mode of children of a given root task, without changing\n     * the windowing mode of the Task itself. This can be used during transitions\n     * for example to make the activity render it's fullscreen configuration\n     * while the Task is still in PIP, so you can complete the animation.\n     *\n     * TODO(b/134365562): Can be removed once TaskOrg drives full-screen\n     ",
    "links" : [ ]
  }, {
    "name" : "public WindowContainerTransaction setWindowingMode(@NonNull WindowContainerToken container, int windowingMode)",
    "returnType" : "WindowContainerTransaction",
    "comment" : "\n     * Sets the windowing mode of the given container.\n     ",
    "links" : [ ]
  }, {
    "name" : "public WindowContainerTransaction setFocusable(@NonNull WindowContainerToken container, boolean focusable)",
    "returnType" : "WindowContainerTransaction",
    "comment" : "\n     * Sets whether a container or any of its children can be focusable. When {@code false}, no\n     * child can be focused; however, when {@code true}, it is still possible for children to be\n     * non-focusable due to WM policy.\n     ",
    "links" : [ ]
  }, {
    "name" : "public WindowContainerTransaction setHidden(@NonNull WindowContainerToken container, boolean hidden)",
    "returnType" : "WindowContainerTransaction",
    "comment" : "\n     * Sets whether a container or its children should be hidden. When {@code false}, the existing\n     * visibility of the container applies, but when {@code true} the container will be forced\n     * to be hidden.\n     ",
    "links" : [ ]
  }, {
    "name" : "public WindowContainerTransaction setSmallestScreenWidthDp(@NonNull WindowContainerToken container, int widthDp)",
    "returnType" : "WindowContainerTransaction",
    "comment" : "\n     * Set the smallestScreenWidth of a container.\n     ",
    "links" : [ ]
  }, {
    "name" : "public WindowContainerTransaction reparent(@NonNull WindowContainerToken child, @Nullable WindowContainerToken parent, boolean onTop)",
    "returnType" : "WindowContainerTransaction",
    "comment" : "\n     * Reparents a container into another one. The effect of a {@code null} parent can vary. For\n     * example, reparenting a stack to {@code null} will reparent it to its display.\n     *\n     * @param onTop When {@code true}, the child goes to the top of parent; otherwise it goes to\n     *              the bottom.\n     ",
    "links" : [ ]
  }, {
    "name" : "public WindowContainerTransaction reorder(@NonNull WindowContainerToken child, boolean onTop)",
    "returnType" : "WindowContainerTransaction",
    "comment" : "\n     * Reorders a container within its parent.\n     *\n     * @param onTop When {@code true}, the child goes to the top of parent; otherwise it goes to\n     *              the bottom.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void merge(WindowContainerTransaction other, boolean transfer)",
    "returnType" : "void",
    "comment" : "\n     * Merges another WCT into this one.\n     * @param transfer When true, this will transfer everything from other potentially leaving\n     *                 other in an unusable state. When false, other is left alone, but\n     *                 SurfaceFlinger Transactions will not be merged.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Map<IBinder, Change> getChanges()",
    "returnType" : "Map<IBinder, Change>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public List<HierarchyOp> getHierarchyOps()",
    "returnType" : "List<HierarchyOp>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void writeToParcel(@NonNull Parcel dest, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "mChanges", "mHierarchyOps", "CREATOR" ],
  "methodNames" : [ "private Change getOrCreateChange(IBinder token)", "public WindowContainerTransaction setBounds(@NonNull WindowContainerToken container, @NonNull Rect bounds)", "public WindowContainerTransaction setAppBounds(@NonNull WindowContainerToken container, @NonNull Rect appBounds)", "public WindowContainerTransaction setScreenSizeDp(@NonNull WindowContainerToken container, int w, int h)", "public WindowContainerTransaction scheduleFinishEnterPip(@NonNull WindowContainerToken container, @NonNull Rect bounds)", "public WindowContainerTransaction setBoundsChangeTransaction(@NonNull WindowContainerToken container, @NonNull SurfaceControl.Transaction t)", "public WindowContainerTransaction setBoundsChangeTransaction(@NonNull WindowContainerToken task, @NonNull Rect surfaceBounds)", "public WindowContainerTransaction setActivityWindowingMode(@NonNull WindowContainerToken container, int windowingMode)", "public WindowContainerTransaction setWindowingMode(@NonNull WindowContainerToken container, int windowingMode)", "public WindowContainerTransaction setFocusable(@NonNull WindowContainerToken container, boolean focusable)", "public WindowContainerTransaction setHidden(@NonNull WindowContainerToken container, boolean hidden)", "public WindowContainerTransaction setSmallestScreenWidthDp(@NonNull WindowContainerToken container, int widthDp)", "public WindowContainerTransaction reparent(@NonNull WindowContainerToken child, @Nullable WindowContainerToken parent, boolean onTop)", "public WindowContainerTransaction reorder(@NonNull WindowContainerToken child, boolean onTop)", "public void merge(WindowContainerTransaction other, boolean transfer)", "public Map<IBinder, Change> getChanges()", "public List<HierarchyOp> getHierarchyOps()", "public String toString()", "public void writeToParcel(@NonNull Parcel dest, int flags)", "public int describeContents()" ]
}